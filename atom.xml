<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cruising</title>
  <icon>https://www.gravatar.com/avatar/55b216e537110a227c1304f63c12f683</icon>
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2018-09-14T02:41:17.896Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Aspirin</name>
    <email>kinomu@sina.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫 - 豆瓣 Top 250</title>
    <link href="http://example.com/2018/09/13/%E7%88%AC%E8%99%AB%20-%20%E8%B1%86%E7%93%A3%20Top%20250/"/>
    <id>http://example.com/2018/09/13/%E7%88%AC%E8%99%AB%20-%20%E8%B1%86%E7%93%A3%20Top%20250/</id>
    <published>2018-09-12T16:00:00.000Z</published>
    <updated>2018-09-14T02:41:17.896Z</updated>
    
    <content type="html"><![CDATA[<p>豆瓣作为一款集书影音评论的网站 ，却还提供了各种其他有趣的多服务，这更像是一个社区。往往这样的网站中会有非常多有趣的数据，今天就来尝试爬一下，做一个数据集出来。起初就在这个网站看到有一个专门的Top250榜单，官方说是根据书&#x2F;电影&#x2F;音乐所看过或听过的人数，以及该项目所得的评价等综合数据，通过算法分析 产生的。那今天的主要目的就来爬一下这些个Top250。代码写的很水，希望能有人不吝赐教。</p><span id="more"></span><h2 id="爬取目标"><a href="#爬取目标" class="headerlink" title="爬取目标"></a>爬取目标</h2><ul><li><a href="https://movie.douban.com/top250?start=0">豆瓣电影 Top 250</a>  &gt;&gt; <strong>电影名,导演,年份,制片地区,电影分类,豆瓣评分,评论人数,描述</strong> &lt;&lt;</li><li><a href="https://book.douban.com/top250?start=0">豆瓣图书 Top 250</a>  &gt;&gt; <strong>书名,作者,售价,豆瓣评分,评论人数,描述</strong> &lt;&lt;</li><li><a href="https://music.douban.com/top250?start=0">豆瓣音乐 Top 250</a>  &gt;&gt; <strong>名称,作者,年份,类型,介质,风格,豆瓣评分,评论人数</strong> &lt;&lt;</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="爬取豆瓣电影-Top-250"><a href="#爬取豆瓣电影-Top-250" class="headerlink" title="爬取豆瓣电影 Top 250"></a>爬取豆瓣电影 Top 250</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: Yu</span></span><br><span class="line"><span class="string">@contact: kinomu@sina.com</span></span><br><span class="line"><span class="string">@file: DoubanMovieSpider.py</span></span><br><span class="line"><span class="string">@time: 2018/9/13 9:27</span></span><br><span class="line"><span class="string">@desc: 豆瓣电影 Top 250 爬虫</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从网页上获取电影数据</span></span><br><span class="line">filmsdata = []</span><br><span class="line">root = <span class="number">10000</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 地址 start=0为第一页，25为第二页以此类推，top250则250为最后一页,循环10次，每次递增25</span></span><br><span class="line">    url = <span class="string">&#x27;https://movie.douban.com/top250?start=&#x27;</span> + <span class="built_in">str</span>(<span class="number">25</span>*i)</span><br><span class="line">    <span class="comment"># 获取网页 text</span></span><br><span class="line">    data = requests.get(url).text</span><br><span class="line">    <span class="comment"># 构建 etree html对象</span></span><br><span class="line">    html = etree.HTML(data)</span><br><span class="line">    <span class="comment"># 找到目标的父级元素</span></span><br><span class="line">    films = html.xpath(<span class="string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ol/li&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> film <span class="keyword">in</span> films:</span><br><span class="line">        _title = film.xpath(<span class="string">&#x27;./div/div[2]/div[1]/a/span[1]/text()&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 电影标题</span></span><br><span class="line">        film_info = film.xpath(<span class="string">&#x27;./div/div[2]/div[2]/p/text()&#x27;</span>)  <span class="comment"># 电影信息</span></span><br><span class="line">        _director = film_info[<span class="number">0</span>].strip(<span class="string">&#x27;\n&#x27;</span>).strip(<span class="string">&#x27;\xa0&#x27;</span>).strip(<span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27;\xa0&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]  <span class="comment"># 电影信息中获取导演信息</span></span><br><span class="line">        detailed = film_info[<span class="number">1</span>].strip(<span class="string">&#x27;\n&#x27;</span>).strip(<span class="string">&#x27;\xa0&#x27;</span>).strip(<span class="string">&#x27; &#x27;</span>) <span class="comment"># 获取电影的详情，包括日期/ 地区/ 类型</span></span><br><span class="line">        _year = detailed.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>].strip(<span class="string">&#x27;\xa0&#x27;</span>)  <span class="comment"># 年份</span></span><br><span class="line">        _area = detailed.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">1</span>].strip(<span class="string">&#x27;\xa0&#x27;</span>)  <span class="comment"># 制片国家/地区</span></span><br><span class="line">        _<span class="built_in">type</span> = detailed.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">2</span>].strip(<span class="string">&#x27;\xa0&#x27;</span>).strip(<span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># 类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取更多信息，包括 评分，评价人数</span></span><br><span class="line">        _score = <span class="string">&#x27;\t&#x27;</span>+film.xpath(<span class="string">&#x27;./div/div[2]/div[2]/div/span[2]/text()&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 评分</span></span><br><span class="line">        _count = film.xpath(<span class="string">&#x27;./div/div[2]/div[2]/div/span[4]/text()&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;人&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 获取简单描述</span></span><br><span class="line">        _content = film.xpath(<span class="string">&#x27;./div/div[2]/div[2]/p[2]/span/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        _index = count + root</span><br><span class="line">        _<span class="built_in">all</span> = [_index, _title, _director, _year, _area, _<span class="built_in">type</span>, _score, _count, _content]</span><br><span class="line">        filmsdata.append(_<span class="built_in">all</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据写入CSV文件中</span></span><br><span class="line">csv_file = <span class="string">&#x27;film_top250.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(csv_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> _file:</span><br><span class="line">    writer = csv.writer(_file)</span><br><span class="line">    header = [<span class="string">&#x27;序号&#x27;</span>, <span class="string">&#x27;电影名&#x27;</span>, <span class="string">&#x27;导演&#x27;</span>, <span class="string">&#x27;年份&#x27;</span>, <span class="string">&#x27;制片地区&#x27;</span>, <span class="string">&#x27;电影分类&#x27;</span>, <span class="string">&#x27;豆瓣评分&#x27;</span>, <span class="string">&#x27;评论人数&#x27;</span>, <span class="string">&#x27;描述&#x27;</span>]</span><br><span class="line">    writer.writerow(header)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> filmsdata:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        writer.writerow(row)</span><br></pre></td></tr></table></figure><h3 id="爬取豆瓣图书-Top-250"><a href="#爬取豆瓣图书-Top-250" class="headerlink" title="爬取豆瓣图书 Top 250"></a>爬取豆瓣图书 Top 250</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: Yu</span></span><br><span class="line"><span class="string">@contact: kinomu@sina.com</span></span><br><span class="line"><span class="string">@file: BookSpider.py</span></span><br><span class="line"><span class="string">@time: 2018/9/13 10:01</span></span><br><span class="line"><span class="string">@desc: 豆瓣图书 Top 250</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从网页上获取图书数据</span></span><br><span class="line">bookdata = []</span><br><span class="line">root = <span class="number">20000</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    url = <span class="string">&#x27;https://book.douban.com/top250?start=&#x27;</span> + <span class="built_in">str</span>(<span class="number">25</span>*i)</span><br><span class="line">    <span class="comment"># 获取网页 text  并 构建 etree html对象</span></span><br><span class="line">    data = requests.get(url).text</span><br><span class="line">    html = etree.HTML(data)</span><br><span class="line">    books = html.xpath(<span class="string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/div/table&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">        _name = book.xpath(<span class="string">&#x27;./tr/td[2]/div/a/@title&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 书名</span></span><br><span class="line">        alias = book.xpath(<span class="string">&#x27;./tr/td[2]/div/span[1]/text()&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(alias) == <span class="number">0</span>:</span><br><span class="line">            alias.append(<span class="string">&#x27;(无)&#x27;</span>)</span><br><span class="line">        _othername = alias[<span class="number">0</span>]  <span class="comment"># 外文名(国内作家所著书无外文名)</span></span><br><span class="line">        info = book.xpath(<span class="string">&#x27;./tr/td[2]/p[1]/text()&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        _author = info[<span class="number">0</span>].strip().replace(<span class="string">&#x27; 口述&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;著&#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 作者</span></span><br><span class="line">        <span class="comment"># 数据处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;]&#x27;</span> <span class="keyword">in</span> _author:</span><br><span class="line">            _author = _author.split(<span class="string">&#x27;]&#x27;</span>)[<span class="number">1</span>].strip().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> _author[<span class="number">0</span>] == <span class="string">&#x27;（&#x27;</span>:</span><br><span class="line">            _author = _author.split(<span class="string">&#x27;）&#x27;</span>)[<span class="number">1</span>].replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;】&#x27;</span> <span class="keyword">in</span> _author:</span><br><span class="line">            _author = _author.split(<span class="string">&#x27;】&#x27;</span>)[<span class="number">1</span>].replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        _price = info[-<span class="number">1</span>].replace(<span class="string">&#x27;元&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;RMB&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;CNY&#x27;</span>,<span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 图数售价</span></span><br><span class="line">        _score = <span class="string">&#x27;\t&#x27;</span>+book.xpath(<span class="string">&#x27;./tr/td[2]/div[2]/span[2]/text()&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 评分</span></span><br><span class="line">        _count = book.xpath(<span class="string">&#x27;./tr/td[2]/div[2]/span[3]/text()&#x27;</span>)[<span class="number">0</span>]\</span><br><span class="line">            .replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip().split(<span class="string">&#x27;人&#x27;</span>)[<span class="number">0</span>]  <span class="comment"># 评论人数</span></span><br><span class="line">        _content = book.xpath(<span class="string">&#x27;./tr/td[2]/p[2]/span/text()&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(_content) == <span class="number">0</span>:</span><br><span class="line">            _content.append(<span class="string">&#x27;(无)&#x27;</span>)</span><br><span class="line">        _content = _content[<span class="number">0</span>]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        _index = root + count</span><br><span class="line">        <span class="comment"># 封装数据</span></span><br><span class="line">        bookdata.append([_index, _name, _author, _price, _score, _count, _content])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据写入CSV文件中</span></span><br><span class="line">csv_file = <span class="string">&#x27;book_top250.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(csv_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> _file:</span><br><span class="line">    writer = csv.writer(_file)</span><br><span class="line">    header = [<span class="string">&#x27;序号&#x27;</span>, <span class="string">&#x27;书名&#x27;</span>, <span class="string">&#x27;作者&#x27;</span>, <span class="string">&#x27;售价&#x27;</span>, <span class="string">&#x27;豆瓣评分&#x27;</span>, <span class="string">&#x27;评论人数&#x27;</span>, <span class="string">&#x27;描述&#x27;</span>]</span><br><span class="line">    writer.writerow(header)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> bookdata:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        writer.writerow(row)</span><br></pre></td></tr></table></figure><h3 id="爬取豆瓣音乐-Top-250"><a href="#爬取豆瓣音乐-Top-250" class="headerlink" title="爬取豆瓣音乐 Top 250"></a>爬取豆瓣音乐 Top 250</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding:utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: Lin Yu</span></span><br><span class="line"><span class="string">@contact: kinomu@sina.com</span></span><br><span class="line"><span class="string">@file: MusicSpider.py</span></span><br><span class="line"><span class="string">@time: 2018/9/13 10:22</span></span><br><span class="line"><span class="string">@desc: 豆瓣音乐 Top 250 爬虫</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从网页上获取数据</span></span><br><span class="line">musicdata = []</span><br><span class="line">root = <span class="number">3000</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 构建 etree html对象</span></span><br><span class="line">    url = <span class="string">&#x27;https://music.douban.com/top250?start=&#x27;</span> + <span class="built_in">str</span>(<span class="number">25</span> * i)</span><br><span class="line">    data = requests.get(url).text</span><br><span class="line">    html = etree.HTML(data)</span><br><span class="line">    <span class="comment"># 找到目标父级元素</span></span><br><span class="line">    music_set = html.xpath(<span class="string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/div/table&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> music <span class="keyword">in</span> music_set:</span><br><span class="line">        title_author = music.xpath(<span class="string">&#x27;./tr/td[1]/a/@title&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        _title = title_author[<span class="number">1</span>]    <span class="comment"># 标题</span></span><br><span class="line">        _author = title_author[<span class="number">0</span>]   <span class="comment"># 作者</span></span><br><span class="line">        info = music.xpath(<span class="string">&#x27;./tr/td[2]/div/p[1]/text()&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27; / &#x27;</span>)</span><br><span class="line">        _date = <span class="string">&#x27;\t&#x27;</span>+info[<span class="number">1</span>]\</span><br><span class="line">            .replace(<span class="string">&#x27;年&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;月&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;-&#x27;</span>)\</span><br><span class="line">            .strip(<span class="string">&#x27;-&#x27;</span>)     <span class="comment"># 日期</span></span><br><span class="line">        _<span class="built_in">type</span> = info[<span class="number">2</span>]     <span class="comment"># 类型</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(info) == <span class="number">5</span>:</span><br><span class="line">            _media = info[<span class="number">3</span>]    <span class="comment"># 介质</span></span><br><span class="line">            _style = info[<span class="number">4</span>]    <span class="comment"># 风格</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(info) == <span class="number">4</span>:</span><br><span class="line">            _media = info[-<span class="number">1</span>]</span><br><span class="line">            _style = <span class="string">&#x27;(未知)&#x27;</span></span><br><span class="line">        _score = <span class="string">&#x27;\t&#x27;</span>+music.xpath(<span class="string">&#x27;./tr/td[2]/div/div[1]/span[2]/text()&#x27;</span>)[<span class="number">0</span>]    <span class="comment"># 评分</span></span><br><span class="line">        target = <span class="string">&#x27;./tr/td[2]/div/div[1]/span[3]/text()&#x27;</span></span><br><span class="line">        _count = music.xpath(target)[<span class="number">0</span>].replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip().split(<span class="string">&#x27;人&#x27;</span>)[<span class="number">0</span>] <span class="comment"># 评论人数</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        _index = root + count</span><br><span class="line">        musicdata.append([_index, _title, _author, _date, _<span class="built_in">type</span>, _media, _style, _score, _count])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据写入CSV文件中</span></span><br><span class="line">csv_file = <span class="string">&#x27;music_top250.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(csv_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> _file:</span><br><span class="line">    writer = csv.writer(_file)</span><br><span class="line">    header = [<span class="string">&#x27;序号&#x27;</span>, <span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;作者&#x27;</span>, <span class="string">&#x27;年份&#x27;</span>, <span class="string">&#x27;类型&#x27;</span>, <span class="string">&#x27;介质&#x27;</span>, <span class="string">&#x27;风格&#x27;</span>, <span class="string">&#x27;豆瓣评分&#x27;</span>, <span class="string">&#x27;评论人数&#x27;</span>]</span><br><span class="line">    writer.writerow(header)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> musicdata:</span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line">        writer.writerow(row)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;豆瓣作为一款集书影音评论的网站 ，却还提供了各种其他有趣的多服务，这更像是一个社区。往往这样的网站中会有非常多有趣的数据，今天就来尝试爬一下，做一个数据集出来。起初就在这个网站看到有一个专门的Top250榜单，官方说是根据书&amp;#x2F;电影&amp;#x2F;音乐所看过或听过的人数，以及该项目所得的评价等综合数据，通过算法分析 产生的。那今天的主要目的就来爬一下这些个Top250。代码写的很水，希望能有人不吝赐教。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="数据" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Neo4j Cypher 语法参考</title>
    <link href="http://example.com/2018/09/12/Neo4j%20Cypher%20%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/"/>
    <id>http://example.com/2018/09/12/Neo4j%20Cypher%20%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2018-09-12T06:33:32.304Z</updated>
    
    <content type="html"><![CDATA[<p>本文以 <strong>Neo4j</strong> 官网上的 <a href="https://neo4j.com/docs/cypher-refcard/current/"><strong>Neo4j Cypher Refcard 3.4</strong></a>为基准，通篇翻译以作学习。即便版本发生改变 ，但其语法以及其作用不会发生太大的变化，放心食用，个人建议原文口味更佳。</p><span id="more"></span><h2 id="Read-Query-Structure"><a href="#Read-Query-Structure" class="headerlink" title="Read Query Structure"></a>Read Query Structure</h2><table><thead><tr><th align="left">Read Query Structure</th></tr></thead><tbody><tr><td align="left">[MATCH WHERE]</td></tr><tr><td align="left">[OPTIONAL MATCH WHERE]</td></tr><tr><td align="left">[WITH [ORDER BY] [SKIP] [LIMIT]]</td></tr><tr><td align="left">RETURN [ORDER BY] [SKIP] [LIMIT]</td></tr></tbody></table><h2 id="MATCH"><a href="#MATCH" class="headerlink" title="MATCH"></a>MATCH</h2><table><thead><tr><th align="left">MATCH</th></tr></thead><tbody><tr><td align="left">MATCH (n:Person)-[:KNOWS]-&gt;(m:Person) WHERE n.name &#x3D; ‘Alice’  [^1]</td></tr><tr><td align="left">MATCH (n)–&gt;(m) [^2]</td></tr><tr><td align="left">MATCH (n {name:’Alice’})–&gt;(m) [^3]</td></tr><tr><td align="left">MATCH p &#x3D; (n)–&gt;(m) [^4]</td></tr><tr><td align="left">OPTIONAL MATCH (n)-[r]-&gt;(m) [^5]</td></tr></tbody></table><p>[^1]: 节点模式（Node patterns）可包含标签以及属性<br>[^2]: MATCH中可以使用所有的模式<br>[^3]: 具有节点属性的模式<br>[^4]: 将路径赋值与p<br>[^5]: 可选模式：空值将用于丢失的部分</p><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><table><thead><tr><th align="left">WHERE</th></tr></thead><tbody><tr><td align="left">WHERE n.property &lt;&gt; $value [^6]</td></tr></tbody></table><p>[^ 6]: WHERE始终是MATCH，OPTIONAL MATCH，WITH或START子句的一部分。 将它放在查询中的不同子句之后将改变它的作用</p><h2 id="RETURN"><a href="#RETURN" class="headerlink" title="RETURN"></a>RETURN</h2><table><thead><tr><th align="left">RETURN</th></tr></thead><tbody><tr><td align="left">RETURN * [^7]</td></tr><tr><td align="left">RETURN n AS columnName [^8]</td></tr><tr><td align="left">RETURN DISTINCT n [^9]</td></tr><tr><td align="left">ORDER BY n.property [^10]</td></tr><tr><td align="left">ORDER BY n.property DESC [^11]</td></tr><tr><td align="left">SKIP $skipNumber [^12]</td></tr><tr><td align="left">LIMIT $limitNumber [^13]</td></tr><tr><td align="left">SKIP $skipNumber LIMIT $limitNumber [^14]</td></tr><tr><td align="left">RETURN count(*) [^15]</td></tr></tbody></table><p>[^15]: 返回的总数（count - 聚合函数）</p><h2 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h2><table><thead><tr><th align="left">WITH</th></tr></thead><tbody><tr><td align="left">MATCH (user)-[:FRIEND]-(friend)<br/>WHERE user.name &#x3D; $name</td></tr><tr><td align="left">WITH user, count(friend) AS friends</td></tr><tr><td align="left">WHERE friends &gt; 10</td></tr><tr><td align="left">RETURN user [^16]</td></tr></tbody></table><p>[^16]: WITH语法类似于RETURN。 它明确地分隔查询部分，允许声明要将哪些变量转移到下一个部分。</p><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><table><thead><tr><th align="left">UNION</th></tr></thead><tbody><tr><td align="left">MATCH (a)-[:KNOWS]-&gt;(b)<br/>RETURN b.name</td></tr><tr><td align="left">UNION</td></tr><tr><td align="left">MATCH (a)-[:LOVES]-&gt;(b)</td></tr><tr><td align="left">RETURN b.name [^17]</td></tr></tbody></table><h2 id="Write-Only-Query-Structure"><a href="#Write-Only-Query-Structure" class="headerlink" title="Write-Only Query Structure"></a>Write-Only Query Structure</h2><table><thead><tr><th align="left">Write-Only Query Structure</th></tr></thead><tbody><tr><td align="left">(CREATE [UNIQUE] | MERGE) *</td></tr><tr><td align="left">[SET | DELETE | REMOVE | FOREACH] *</td></tr><tr><td align="left">[RETURN [ORDER BY] [SKIP] [LIMIT]]</td></tr></tbody></table><h2 id="Read-Write-Query-Structure"><a href="#Read-Write-Query-Structure" class="headerlink" title="Read-Write Query Structure"></a>Read-Write Query Structure</h2><table><thead><tr><th align="left">Read-Write Query Structure</th></tr></thead><tbody><tr><td align="left">[MATCH WHERE]</td></tr><tr><td align="left">[OPTIONAL MATCH WHERE]</td></tr><tr><td align="left">[WITH [ORDER BY] [SKIP] [LIMIT]]</td></tr><tr><td align="left">(CREATE [UNIQUE] | MERGE) *</td></tr><tr><td align="left">[SET | DELETE | REMOVE | FOREACH] *</td></tr><tr><td align="left">[RETURN [ORDER BY] [SKIP] [LIMIT]]</td></tr></tbody></table><h2 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h2><table><thead><tr><th align="left">CREATE</th></tr></thead><tbody><tr><td align="left">CREATE (n {name: $value}) [^18]</td></tr><tr><td align="left">CREATE (n $map) [^18]</td></tr><tr><td align="left">UNWIND $listOfMaps AS properties<br/>CREATE (n) SET n &#x3D; properties [^18]</td></tr><tr><td align="left">CREATE (n)-[r:KNOWS]-&gt;(m) [^19]</td></tr><tr><td align="left">CREATE (n)-[:LOVES {since: $value}]-&gt;(m) [^20]</td></tr></tbody></table><p>[^19]: 创建具有给定类型和方向的关系; 将变量绑定到它。<br>[^20]: 使用给定的类型，方向和属性创建关系。</p><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><table><thead><tr><th>CREATE</th></tr></thead><tbody><tr><td>SET n.property1 &#x3D; $value1,<br/>n.property2 &#x3D; $value2 [^21]</td></tr><tr><td>SET n &#x3D; $map [^22]</td></tr><tr><td>SET n +&#x3D; $map [^23]</td></tr><tr><td>SET n:Person [^24]</td></tr></tbody></table><p>[^22]: 设置所有属性。 这将删除任何现有属性<br>[^23]: 添加和更新属性，同时保留现有属性<br>[^24]: 向节点添加标签Person</p><h2 id="MERGE"><a href="#MERGE" class="headerlink" title="MERGE"></a>MERGE</h2><table><thead><tr><th>MERGE</th></tr></thead><tbody><tr><td>MERGE (n:Person {name: $value})<br/>ON CREATE SET n.created &#x3D; timestamp()</td></tr><tr><td>ON MATCH SET</td></tr><tr><td>n.counter &#x3D; coalesce(n.counter, 0) + 1,</td></tr><tr><td>n.accessTime &#x3D; timestamp() [^25]</td></tr><tr><td>MATCH (a:Person {name: $value1})<br/>MERGE</td></tr><tr><td>(a)-[r:KNOWS]-&gt;(b:Person {name: $value3}) [^26]</td></tr></tbody></table><p>[^25]: 匹配模式或创建模式（如果不存在）。 使用ON CREATE和ON MATCH进行条件更新。<br>[^26]: MERGE查找或创建附加到节点的子图。</p><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><table><thead><tr><th>DELETE</th></tr></thead><tbody><tr><td>DELETE n, r [^27]</td></tr><tr><td>DETACH DELETE n [^28]</td></tr><tr><td>MATCH (n)<br/>DETACH DELETE n [^29]</td></tr></tbody></table><h2 id="REMOVE"><a href="#REMOVE" class="headerlink" title="REMOVE"></a>REMOVE</h2><table><thead><tr><th>REMOVE</th></tr></thead><tbody><tr><td>REMOVE n:Person [^30]</td></tr><tr><td>REMOVE n.property [^31]</td></tr></tbody></table><h2 id="FOREACH"><a href="#FOREACH" class="headerlink" title="FOREACH"></a>FOREACH</h2><table><thead><tr><th>FOREACH</th></tr></thead><tbody><tr><td>FOREACH (r IN relationships(path)| <br/>SET r.marked &#x3D; true) [^32]</td></tr><tr><td>FOREACH (value IN coll | <br/>CREATE (:Person {name: value})) [^33]</td></tr></tbody></table><h2 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h2><table><thead><tr><th>CALL</th></tr></thead><tbody><tr><td>CALL db.labels() YIELD label [^34]</td></tr><tr><td>CALL java.stored.procedureWithArgs [^35]</td></tr><tr><td>CALL db.labels() YIELD label<br/>RETURN count(label) AS count [^36]</td></tr></tbody></table><p>[^34]: 这显示了对内置过程db.labels的独立调用，以列出数据库中使用的所有标签。 请注意，在过程名称后面的括号中明确给出了必需的过程参数。<br>[^35]: 独立调用可以省略YIELD并且还通过语句参数隐式地提供参数，例如， 需要一个参数输入的独立调用可以通过传递参数map {input：’foo’}来运行。<br>[^36]: 在较大的查询中调用内置过程db.labels来计算数据库中使用的所有标签。 在较大的查询中调用总是需要传递参数并使用YIELD显式命名结果。</p><h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><p><code>LOAD CSV FROM &#39;https://neo4j.com/docs/cypher-refcard/3.4/csv/artists.csv&#39; AS line CREATE (:Artist &#123;name: line[1], year: toInteger(line[2])&#125;)</code><a href="%E4%BB%8ECSV%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9%E3%80%82">^37</a></p><p><code>LOAD CSV WITH HEADERS FROM &#39;https://neo4j.com/docs/cypher-refcard/3.4/csv/artists-with-headers.csv&#39; AS line CREATE (:Artist &#123;name: line.Name, year: toInteger(line.Year)&#125;)</code> <a href="%E5%8A%A0%E8%BD%BD%E5%8C%85%E5%90%AB%E6%A0%87%E9%A2%98%E7%9A%84CSV%E6%95%B0%E6%8D%AE%E3%80%82">^38</a></p><p><code>USING PERIODIC COMMIT 500 LOAD CSV WITH HEADERS FROM &#39;https://neo4j.com/docs/cypher-refcard/3.4/csv/artists-with-headers.csv&#39; AS line CREATE (:Artist &#123;name: line.Name, year: toInteger(line.Year)&#125;)</code> <a href="%E5%AF%BC%E5%85%A5%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E6%AF%8F500%E8%A1%8C%E6%8F%90%E4%BA%A4%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E3%80%82">^39</a></p><p><code>LOAD CSV FROM &#39;https://neo4j.com/docs/cypher-refcard/3.4/csv/artists-fieldterminator.csv&#39; AS line FIELDTERMINATOR &#39;;&#39; CREATE (:Artist &#123;name: line[1], year: toInteger(line[2])&#125;)</code> <a href="%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%97%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%AC%A6%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%8C%E5%8D%B3%E9%80%97%E5%8F%B7%EF%BC%88%E4%B8%8D%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%EF%BC%89%E3%80%82">^40</a></p><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><table><thead><tr><th>–</th><th>–</th></tr></thead><tbody><tr><td>General</td><td>DISTINCT, ., []</td></tr><tr><td>Mathematical</td><td>+，-，*，&#x2F;，%，^</td></tr><tr><td>Comparison</td><td>&#x3D;, &lt;&gt;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;, IS NULL, IS NOT NULL</td></tr><tr><td>Boolean</td><td>AND, OR, XOR, NOT</td></tr><tr><td>String</td><td>+</td></tr><tr><td>List</td><td>+，IN，[x]，[x .. y]</td></tr><tr><td>Regular Expression</td><td>&#x3D;~</td></tr><tr><td>String matching</td><td>STARTS WITH, ENDS WITH，CONTAINS</td></tr></tbody></table><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><ul><li>null用于表示缺失&#x2F;未定义的值。</li><li>null不等于null。 不知道两个值并不意味着它们是相同的值。 所以表达式null &#x3D; null产生null而不是true。 要检查表达式是否为null，请使用IS NULL。</li><li>如果任何参数为null，则算术表达式，比较和函数调用（coalesce除外）将返回null。</li><li>尝试访问列表中缺少的元素或不存在的属性会产生null。</li><li>在OPTIONAL MATCH子句中，空值将用于模式的缺失部分。</li></ul><h2 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h2><p><code>(n:Person)</code>：带有Person标签的节点。</p><p><code>(n:Person:Swedish)</code>：具有Person和Swedish标签的节点。</p><p><code>(n:Person &#123;name: $value&#125;)</code>具有声明属性的节点。</p><p><code>()-[r &#123;name: $value&#125;]-()</code>匹配与声明的属性的关系。</p><p><code>(n)--&gt;(m)</code>从n到m的关系。</p><p><code>(n)--(m)</code>n和m之间任意方向的关系。</p><p><code>(n:Person)--&gt;(m)</code>节点n标记为与m有关系的Person。</p><p><code>(m)&lt;-[:KNOWS]-(n)</code>从n到m的KNOWS类型的关系。</p><p><code>(n)-[:KNOWS|:LOVES]-&gt;(m)</code>类型为KNOWS或类型为LOVES的关系，从n到m。</p><p><code>(n)-[r]-&gt;(m)</code>将关系绑定到变量r。</p><p><code>(n)-[*1..5]-&gt;(m)</code>从n到m的1到5个关系之间的可变长度路径。</p><p><code>(n)-[*]-&gt;(m)</code>从n到m的任意数量关系的可变长度路径。</p><p><code>(n)-[:KNOWS]-&gt;(m &#123;property: $value&#125;)</code>从节点n到具有声明属性的节点m的KNOWS类型的关系。</p><p><code>shortestPath((n1:Person)-[*..6]-(n2:Person))</code>找到一条最短的路径。</p><p><code>allShortestPaths((n1:Person)-[*..6]-&gt;(n2:Person))</code>找到所有最短的路径。</p><p><code>size((n)--&gt;()--&gt;())</code>计算与模式匹配的路径。</p><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] AS list</code>文字列表在方括号中声明。</p><p><code>size($list) AS len, $list[0] AS value</code>列表可以作为参数传递。</p><p><code>range($firstNum, $lastNum, $step) AS list</code>range()创建一个数字列表（步骤是可选的），返回列表的其他函数是：labels()，nodes()，relationships()，filter()，extract()。</p><p><code>MATCH p = (a)-[:KNOWS*]-&gt;() RETURN relationships(p) AS r</code> 可以使用命名路径和relationships()返回包含可变长度路径的关系列表。</p><p><code>RETURN matchedNode.list[0] AS value, size(matchedNode.list) AS len</code>属性可以是字符串，数字或布尔值的列表。</p><p><code>list[$idx] AS value, list[$startIdx..$endIdx] AS slice</code>可以使用方括号中的idx下标访问列表元素。 无效索引返回null。 可以从start_idx到end_idx的间隔检索切片，每个切片可以省略或为负。 超出范围的元素将被忽略。</p><p><code>UNWIND $names AS name MATCH (n &#123;name: name&#125;) RETURN avg(n.age)</code>使用UNWIND，任何列表都可以转换回单个行。 该示例匹配名称列表中的所有名称。</p><p><code>MATCH (a) RETURN [(a)--&gt;(b) WHERE b.name = &#39;Bob&#39; | b.age]</code>模式推导可用于从匹配中直接进行自定义投影到列表中。</p><p><code>MATCH (person) RETURN person &#123; .name, .age&#125;</code>可以从节点，关系和其他地图值容易地构建地图投影。</p><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><code>&#123;name: &#39;Alice&#39;, age: 38, address: &#123;city: &#39;London&#39;, residential: true&#125;&#125;</code>maps用花括号声明，就像属性贴图一样。 支持列表。</p><p><code>WITH &#123;person: &#123;name: &#39;Anne&#39;, age: 25&#125;&#125; AS p RETURN p.person.name</code>访问嵌套映射的属性。</p><p><code>MERGE (p:Person &#123;name: $map.name&#125;) ON CREATE SET p = $map</code>maps可以作为参数传递，并用作map或访问键。</p><p><code>MATCH (matchedNode:Person) RETURN matchedNode</code>节点和关系将作为其数据的映射返回。</p><p><code>map.name, map.age, map.children[0]</code>可以通过其键访问映射条目。 密钥无效会导致错误</p><h2 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h2><p><code>n.property &lt;&gt; $value</code>使用比较运算符。</p><p><code>exists(n.property)</code>使用函数。</p><p><code>n.number &gt;= 1 AND n.number &lt;= 10</code>使用布尔运算符组合谓词。</p><p><code>1 &lt;= n.number &lt;= 10</code>使用链式运算符组合谓词。</p><p><code>n:Person</code>检查节点标签。</p><p><code>variable IS NULL</code>检查某些内容是否为空。</p><p><code>NOT exists(n.property) OR n.property = $value</code>属性不存在或谓词为真</p><p><code>n.property = $value</code>不存在的属性返回null，它不等于任何东西。</p><p><code>n[&quot;property&quot;] = $value</code>也可以使用动态计算的属性名称访问属性。</p><p><code>n.property STARTS WITH &#39;Tim&#39; OR n.property ENDS WITH &#39;n&#39; OR n.property CONTAINS &#39;goodie&#39;</code>字符串匹配。</p><p><code>n.property =~ &#39;Tim.*&#39;</code>字符串正则表达式匹配</p><p><code>(n)-[:KNOWS]-&gt;(m)</code>确保模式至少有一个匹配。</p><p><code>NOT (n)-[:KNOWS]-&gt;(m)</code>从结果中排除与（n） -  [：KNOWS]  - &gt;（m）的匹配。</p><p><code>n.property IN [$value1, $value2]</code>检查列表中是否存在元素。</p><h2 id="List-Predicates"><a href="#List-Predicates" class="headerlink" title="List Predicates"></a>List Predicates</h2><p><code>all(x IN coll WHERE exists(x.property))</code>如果列表中的所有元素的谓词为true，则返回true。</p><p><code>any(x IN coll WHERE exists(x.property))</code>如果谓词对于列表中的至少一个元素为true，则返回true。</p><p><code>none(x IN coll WHERE exists(x.property))</code>如果列表中的所有元素的谓词为false，则返回true。</p><p><code>single(x IN coll WHERE exists(x.property))</code>如果谓词对于列表中的一个元素为true，则返回true。</p><h2 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h2><p><code>CASE n.eyes WHEN &#39;blue&#39; THEN 1 WHEN &#39;brown&#39; THEN 2 ELSE 3 END</code>从匹配的WHEN值返回THEN值。 ELSE值是可选的，如果缺少则替换为null。</p><p><code>CASE WHEN n.eyes = &#39;blue&#39; THEN 1 WHEN n.age &lt; 40 THEN 2 ELSE 3 END</code>将第一个WHEN谓词评估中的THEN值返回true。 按顺序评估谓词。</p><h2 id="List-Expressions"><a href="#List-Expressions" class="headerlink" title="List Expressions"></a>List Expressions</h2><p><code>size($list)</code>列表中的元素数量。</p><p><code>reverse($list)</code>反转列表中元素的顺序。</p><p><code>head($list), last($list), tail($list)</code>head（）返回第一个，last（）列表的最后一个元素。 tail（）返回除第一个元素之外的所有元素。 对于空列表，所有返回null。</p><p><code>[x IN list WHERE x.prop &lt;&gt; $value | x.prop]</code>过滤器和提取物的组合以简洁的表示法。</p><p><code>extract(x IN list | x.prop)</code>原始列表中每个元素的表达式值列表。</p><p><code>filter(x IN list WHERE x.prop &lt;&gt; $value)</code>谓词为true的元素的筛选列表。</p><p><code>reduce(s = &quot;&quot;, x IN list | s + x.prop)</code>评估列表中每个元素的表达式，累积结果。</p><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><code>coalesce(n.property, $defaultValue)</code>第一个非null表达式。</p><p><code>timestamp()</code>自UTC时间1970年1月1日午夜起的毫秒数。</p><p><code>id(nodeOrRelationship)</code>关系或节点的内部标识。</p><p><code>toInteger($expr)</code>如果可能，将给定输入转换为整数; 否则返回null。</p><p><code>toFloat($expr)</code>如果可能，将给定输入转换为浮点数; 否则返回null。</p><p><code>toBoolean($expr)</code>如果可能，将给定输入转换为布尔值; 否则返回null。</p><p><code>keys($expr)</code>返回节点，关系或映射的属性名称的字符串表示形式的列表。</p><p><code>properties(&#123;expr&#125;)</code>返回包含节点或关系的所有属性的映射。</p><h2 id="Path-Functions"><a href="#Path-Functions" class="headerlink" title="Path Functions"></a>Path Functions</h2><p><code>length(path)</code>路径中的关系数。</p><p><code>nodes(path)</code>路径中的节点作为列表。</p><p><code>relationships(path)</code>路径中的关系作为列表。</p><p><code>extract(x IN nodes(path) | x.prop)</code>从路径中的节点提取属性。</p><h2 id="Spatial-Functions"><a href="#Spatial-Functions" class="headerlink" title="Spatial Functions"></a>Spatial Functions</h2><p><code>point(&#123;x: $x, y: $y&#125;)</code>返回2D笛卡尔坐标系中的点。</p><p><code>point(&#123;latitude: $y, longitude: $x&#125;)</code>返回2D地理坐标系中的点，坐标以十进制度指定。</p><p><code>point(&#123;x: $x, y: $y, z: $z&#125;)</code>返回3D笛卡尔坐标系中的点。</p><p><code>point(&#123;latitude: $y, longitude: $x, height: $z&#125;)</code>返回3D地理坐标系中的点，纬度和经度以十进制度表示，高度以米为单位。</p><p><code>distance(point(&#123;x: $x1, y: $y1&#125;), point(&#123;x: $x2, y: $y2&#125;))</code>返回表示两点之间的线性距离的浮点数。 返回的单位将与点坐标的单位相同，并且它将适用于2D和3D笛卡尔点。</p><p><code>distance(point(&#123;latitude: $y1, longitude: $x1&#125;), point(&#123;latitude: $y2, longitude: $x2&#125;))</code>返回两点之间的测地距离（以米为单位）。 它也可以用于3D地理点。</p><h2 id="Temporal-Functions"><a href="#Temporal-Functions" class="headerlink" title="Temporal Functions"></a>Temporal Functions</h2><p><code>date(&quot;2018-04-05&quot;)</code>返回从字符串解析的日期。</p><p><code>localtime(&quot;12:45:30.25&quot;)</code>返回没有时区的时间。</p><p><code>time(&quot;12:45:30.25+01:00&quot;)</code>返回指定时区的时间。</p><p><code>localdatetime(&quot;2018-04-05T12:34:00&quot;)</code>返回没有时区的日期时间。</p><p><code>datetime(&quot;2018-04-05T12:34:00[Europe/Berlin]&quot;)</code>返回指定时区的日期时间。</p><p><code>datetime(&#123;epochMillis: 3360000&#125;)</code>将3360000作为UNIX纪元时间转换为正常的日期时间。</p><p><code>date(&#123;year: &#123;year&#125;, month: &#123;month&#125;, day: &#123;day&#125;&#125;)</code>还可以使用命名组件的映射来调用所有时间函数。 此示例返回年，月和日组件的日期。 每个函数都支持一组不同的可能组件。</p><p><code>datetime(&#123;date: &#123;date&#125;, time: &#123;time&#125;&#125;)</code>可以通过组合其他类型来创建时间类型。 此示例从日期和时间创建日期时间。</p><p><code>date(&#123;date: &#123;datetime&#125;, day: 5&#125;)</code>可以通过从更复杂的类型中进行选择以及覆盖单个组件来创建时间类型。 此示例通过从日期时间中进行选择以及覆盖日期组件来创建日期。</p><p><code>WITH date(&quot;2018-04-05&quot;) AS d</code>返回d.year，d.month，d.day，d.week，d.dayOfWeek<br>访问器允许提取时间类型的组件。</p><h2 id="Duration-Functions"><a href="#Duration-Functions" class="headerlink" title="Duration Functions"></a>Duration Functions</h2><p><code>duration(&quot;P1Y2M10DT12H45M30.25S&quot;)</code>返回1年，2个月，10天，12小时，45分钟和30.25秒的持续时间。</p><p><code>duration.between($date1,$date2)</code>返回两个临时实例之间的持续时间。</p><p><code>WITH duration(&quot;P1Y2M10DT12H45M&quot;) AS d RETURN d.years, d.months, d.days, d.hours, d.minutes</code>返回1年，14个月，10天，12小时和765分钟。</p><p><code>WITH duration(&quot;P1Y2M10DT12H45M&quot;) AS d RETURN d.years, d.monthsOfYear, d.days, d.hours, d.minutesOfHour</code>返回1年，2个月，10天，12小时45分钟。</p><p><code>date(&quot;2015-01-01&quot;) + duration(&quot;P1Y1M1D&quot;)</code>返回2016-02-02的日期。 也可以从时间实例中减去持续时间。</p><p><code>duration(&quot;PT30S&quot;) * 10</code>返回5分钟的持续时间。 也可以将持续时间除以数字。</p><h2 id="Mathematical-Functions"><a href="#Mathematical-Functions" class="headerlink" title="Mathematical Functions"></a>Mathematical Functions</h2><p><code>abs($expr)</code>绝对值。</p><p><code>rand()</code>返回0（包括）到1（不包括），[0,1）范围内的随机数。 返回每个调用的新值。 也可用于选择子集或随机排序。</p><p><code>round($expr)</code>舍入到最接近的整数; ceil（）和floor（）向上或向下查找下一个整数。</p><p><code>sqrt($expr)</code>平方根。</p><p><code>sign($expr)</code>绝对值。</p><p><code>sin($expr)</code>三角函数还包括cos（），tan（），cot（），asin（），acos（），atan（），atan2（）和hasrsin（）。 如果没有另外指定，三角函数的所有参数都应该是弧度。</p><p><code>degrees($expr), radians($expr), pi()</code>将弧度转换为度数; 使用radians（）作为反向，使用pi（）作为π。</p><p><code>log10($expr), log($expr), exp($expr), e()</code>对数基数10，自然对数，e到参数的幂，以及e的值。</p><h2 id="String-Functions"><a href="#String-Functions" class="headerlink" title="String Functions"></a>String Functions</h2><p><code>toString($expression)</code>表达式的字符串表示形式。</p><p><code>replace($original, $search, $replacement)</code>用替换替换所有出现的搜索。 所有参数都必须是表达式。</p><p><code>substring($original, $begin, $subLength)</code>获取字符串的一部分。 subLength参数是可选的。</p><p><code>left($original, $subLength), right($original, $subLength)</code>字符串的第一部分。 字符串的最后一部分。</p><p><code>trim($original), lTrim($original), rTrim($original)</code>修剪所有空格，或左侧或右侧。</p><p><code>toUpper($original), toLower($original)</code>大写和小写。</p><p><code>split($original, $delimiter)</code>将字符串拆分为字符串列表。</p><p><code>reverse($original)</code>反转一个字符串。</p><p><code>size($string)</code>计算字符串中的字符数。</p><h2 id="Relationship-Functions"><a href="#Relationship-Functions" class="headerlink" title="Relationship Functions"></a>Relationship Functions</h2><p><code>type(a_relationship)</code>关系类型的字符串表示形式。</p><p><code>startNode(a_relationship)</code>关系的起始节点。</p><p><code>endNode(a_relationship)</code>关系的结束节点。</p><p><code>id(a_relationship)</code>关系的内部id。</p><h2 id="Aggregating-Functions"><a href="#Aggregating-Functions" class="headerlink" title="Aggregating Functions"></a>Aggregating Functions</h2><p><code>count(*)</code>匹配行的数量。</p><p><code>count(variable)</code>非空值的数量。</p><p><code>count(DISTINCT variable)</code>所有聚合函数也采用DISTINCT运算符，该运算符从值中删除重复项。</p><p><code>collect(n.property)</code>从值列出，忽略null。</p><p><code>sum(n.property)</code>求和数值。 类似的函数是avg（），min（），max（）。</p><p><code>percentileDisc(n.property, $percentile)</code>离散百分位数。 连续百分位数是百分位数（）。 百分位数参数从0.0到1.0。</p><p><code>stDev(n.property)</code>人口样本的标准差。 对于整个人口使用stDevP（）。</p><h2 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h2><p><code>CREATE INDEX ON :Person(name)</code>在标签Person和property name上创建索引。</p><p><code>MATCH (n:Person) WHERE n.name = $value</code>索引可以自动用于相等比较。 请注意，例如toLower（n.name）&#x3D; $ value将不使用索引。</p><p><code>MATCH (n:Person) WHERE n.name IN [$value]</code>索引可以自动用于IN列表检查。</p><p><code>MATCH (n:Person) USING INDEX n:Person(name) WHERE n.name = $value</code>当Cypher使用次优索引或应使用多个索引时，可以强制执行索引使用。</p><p><code>DROP INDEX ON :Person(name)</code>删除标签Person和property name上的索引。</p><h2 id="CONSTRAINT"><a href="#CONSTRAINT" class="headerlink" title="CONSTRAINT"></a>CONSTRAINT</h2><p><code>CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE</code>在标签Person和属性名称上创建唯一的属性约束。 如果使用已存在的名称更新或创建具有该标签的任何其他节点，则写入操作将失败。 此约束将创建一个附带索引。</p><p><code>DROP CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE</code>删除标签Person和property name上的唯一约束和索引。</p><p><code>CREATE CONSTRAINT ON (p:Person) ASSERT exists(p.name)</code>（★）在标签Person和属性名称上创建节点属性存在约束。 如果创建具有该标签的节点而没有名称，或者如果从具有Person标签的现有节点中删除name属性，则写入操作将失败。</p><p><code>DROP CONSTRAINT ON (p:Person) ASSERT exists(p.name)</code>（★）删除标签Person和property name上的node属性存在约束。</p><p><code>CREATE CONSTRAINT ON ()-[l:LIKED]-() ASSERT exists(l.when)</code>（★）在类型LIKED和属性时创建关系属性存在约束。 如果在没有when的情况下创建了与该类型的关系，或者如果从具有LIKED类型的现有关系中删除了when属性，则写入操作将失败。</p><p><code>DROP CONSTRAINT ON ()-[l:LIKED]-() ASSERT exists(l.when)</code>（★）在类型LIKED和属性时删除关系属性存在约束。</p><p><code>CREATE CONSTRAINT ON (p:Person) ASSERT (p.firstname, p.surname) IS NODE KEY</code>（★）在标签Person和properties firstname和surname上创建一个Node Key约束。 如果创建具有该标签的节点而没有firstname和surname，或者两者的组合不唯一，或者如果修改了具有Person标签的现有节点上的firstname和&#x2F;或surname标签以违反这些约束，则写入 操作将失败。</p><p><code>DROP CONSTRAINT ON (p:Person) ASSERT (p.firstname, p.surname) IS NODE KEY</code>（★）删除标签Person和properties firstname和surname上的Node Key约束。</p><p><span style="color:red">PS:（★）为Neo4j企业版提供的功能。</span></p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><ul><li>尽可能使用参数而不是文字。 这允许Cypher重用您的查询，而不必解析和构建新的执行计划。</li><li>始终为可变长度模式设置上限。 很容易让查询疯狂并错误地触摸图中的所有节点。</li><li>仅返回您需要的数据。 避免返回整个节点和关系 - 而是选择所需的数据并仅返回该数据。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以 &lt;strong&gt;Neo4j&lt;/strong&gt; 官网上的 &lt;a href=&quot;https://neo4j.com/docs/cypher-refcard/current/&quot;&gt;&lt;strong&gt;Neo4j Cypher Refcard 3.4&lt;/strong&gt;&lt;/a&gt;为基准，通篇翻译以作学习。即便版本发生改变 ，但其语法以及其作用不会发生太大的变化，放心食用，个人建议原文口味更佳。&lt;/p&gt;</summary>
    
    
    
    <category term="Cypher" scheme="http://example.com/categories/Cypher/"/>
    
    
    <category term="CQL" scheme="http://example.com/tags/CQL/"/>
    
  </entry>
  
  <entry>
    <title>Neo4j - Cypher Query Language - 入门指引</title>
    <link href="http://example.com/2018/09/06/Neo4j%20-%20Cypher%20Query%20Language%20-%20%E6%8C%87%E5%BC%95/"/>
    <id>http://example.com/2018/09/06/Neo4j%20-%20Cypher%20Query%20Language%20-%20%E6%8C%87%E5%BC%95/</id>
    <published>2018-09-05T16:00:00.000Z</published>
    <updated>2018-09-17T09:52:48.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Cypher Query Language (CQL)</strong> 是 <strong>Neo4j</strong> 所使用的开放图形查询语言。Cypher 的语法提供了一种方式（类SQL）来匹配图中的节点和关系，也就是<strong>模式</strong>。如果具备 <strong>SQL</strong> 的基础，那么学习起 Cypher 就能变得更加容易。这是这篇指引推崇的做法 —— 先掌握SQL基础，再学习 Cypher。除此之外，还需要具备图形数据库和属性图模型的基本概念，以便更好的理解 Cypher 查询。</p><span id="more"></span><h2 id="节点-Nodes"><a href="#节点-Nodes" class="headerlink" title="节点 Nodes"></a>节点 Nodes</h2><p>Cypher 使用 ASCII-Art 来表示模式。就像一个⚪一样，用双括弧来围绕节点，例如<code>(节点A)</code>。在之后如果我们想要引用这个节点，只需要使用一个变量例如<code>(node_a)</code> ，如果关注的问题与节点无关，还可以使用空括弧<code>()</code>。一般情况下，节点还会使用标签来区分实体，同时在Neo4j中，使用标签是一种执行优化的方案。以节点A为例，为其添加标签，如<code>(节点A:标签1)</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (节点A:标签1) return 节点A.某属性</span><br></pre></td></tr></table></figure><p>在进行节点查询时，有时还会用到<code>(emp:Employee)--&gt;(dep:Department)</code>这样的模式，用以查看例如emp.name，dep.no等属性，可以看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (emp:Employee)--&gt;(dep:Department)</span><br><span class="line">where emp.name = &#123;value&#125;</span><br><span class="line">return dep.no,dep.name</span><br></pre></td></tr></table></figure><h2 id="关系-Relationships"><a href="#关系-Relationships" class="headerlink" title="关系 Relationships"></a>关系 Relationships</h2><p>节点与节点之间可以用比直接查询更复杂的模式。关系是用<code>--&gt;</code>来连接两个节点，若要描述关系的类型，则在箭头中增加一对方括号，例如<code>-[]-&gt;</code>，在方括号内写明关系类型。</p><ul><li><strong>关系类型</strong> ：<code>-[:friend]-&gt;</code></li><li><strong>声明关系类型的变量，例如 f</strong>：<code>-[f:friend]-&gt;</code></li><li><strong>附加属性</strong>：<code>-[&#123;date:20180906&#125;]-&gt;</code></li><li><strong>可变长度的路径结构信息</strong>：<code>-[:friend*..3]-&gt;</code></li></ul><p>其中声明关系的变量是为了方便之后对有关关系的信息进行调用。例如friend中有一个until的信息，声明了变量之后就可以用 <strong>变量名.until</strong> 来调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (emp:Employee)-[info:information]-&gt;(dep:Department)</span><br><span class="line">where info.join_time &gt; &#123;value&#125;</span><br><span class="line">return info.join_time, type(info)</span><br></pre></td></tr></table></figure><h2 id="模式-Patterns"><a href="#模式-Patterns" class="headerlink" title="模式 Patterns"></a>模式 Patterns</h2><p>节点和关系的表达式是更为复杂模式的基础，<strong>模式</strong>是可以连续编写的，也可以用逗号进行分隔，同时还可以引用先前声明的变量或引入新的变量。</p><ul><li><strong>找到朋友的朋友</strong>：<code>(me)-[:KNOWS]-(friend)-[:KNOWS]-(she)</code></li><li><strong>最短路径</strong> ：<code>path = shortestPath( (me)-[:KNOWS*..5]-(other_peopel) )</code></li><li><strong>协同过滤</strong>：<code>(someone)-[:PURCHASED]-&gt;(product)&lt;-[:PURCHASED]-()-[:PURCHASED]-&gt;(other_product)</code></li><li><strong>树导航（root）</strong>：<code>(root)&lt;-[:PARENT*]-(leaf:Category)-[:ITEM]-&gt;(data:Product)</code></li></ul><h2 id="Cypher-的实践"><a href="#Cypher-的实践" class="headerlink" title="Cypher 的实践"></a>Cypher 的实践</h2><p>首先通过<code>create</code>来创建一个节点，这里就拿我自己为例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;)</span><br><span class="line">return me</span><br></pre></td></tr></table></figure><p><code>create</code>能够使用标签和属性创建一个节点。除此之外，我想给自己添加一个新的关系，现在想想自己喜欢做什么——比如我喜欢玩《Warframe》这款TPS网游。首先找到自己，并添加一个新的关系到新节点上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;)</span><br><span class="line">create (me)-[play:PLAY]-&gt;(warframe:PC_Game &#123;name:&#x27;Warframe&#x27;&#125;)</span><br><span class="line">return me,play,warframe</span><br></pre></td></tr></table></figure><p>通过上面这两个例子，我们不难发现<code>create</code>不仅能够创建单个节点，同时也可以创建出更复杂的结构。接下来继续创建几个节点，但是每次创建节点都要编写这么长的代码未免太过麻烦，所以这一次除了create，还会用到<code>foreach</code>，循环遍历创建出节点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;)</span><br><span class="line">foreach(n in [&#x27;魏小彬&#x27;,&#x27;陈奕霖&#x27;,&#x27;刘懿辉&#x27;,&#x27;王祎&#x27;,&#x27;陈文辉&#x27;,&#x27;钟滨&#x27;,&#x27;唐建新&#x27;] |</span><br><span class="line">create (me)-[:FRIEND]-&gt;(:Person &#123;name:n&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在循环创建出多个节点之后，把我与朋友们的图给查询出来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;)-[:FRIEND]-&gt;(myFriend)</span><br><span class="line">return me,myFriend</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/06/iCEnot.png" alt="iCEnot.png"></p><p>根据查询出来的图可以看出与我关系为<code>FRIEND</code>的人(节点)一共有7个。假设此时，忽然想起了其中某一个人的老师是Warframe这款游戏的设计师，我们把这个二层关系也创建出来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (warframe:PC_GAME &#123;name:&#x27;Warframe&#x27;&#125;)</span><br><span class="line">match (wangyi:Person &#123;name:&#x27;王祎&#x27;&#125;)</span><br><span class="line">create (wangyi)-[:STUDENT]-&gt;(teacher:Person:GameDesigner &#123;name:&#x27;Sean Bigham&#x27;&#125;)-[:DESIGNED]-&gt;(warframe)</span><br><span class="line">return wangyi,teacher,warframe</span><br></pre></td></tr></table></figure><p>我现在并不知道我的哪一个朋友的老师，是Warframe的设计师，我非常迫切的想要认识那位设计者，这时就可以通过这个<strong>社交网络</strong>找到谁可以帮助我。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (me &#123;name:&#x27;林羽双珏&#x27;&#125;)</span><br><span class="line">match (designer)-[:DESIGNED]-&gt;(warframe:PC_GAME &#123;name:&#x27;Warframe&#x27;&#125;)</span><br><span class="line">match path = shortestPath( (you)-[*..5]-(designer) )</span><br><span class="line">return db,designer,path</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/06/iCEmdI.png" alt="iCEmdI.png"></p><h2 id="CREATE-和-MATCH"><a href="#CREATE-和-MATCH" class="headerlink" title="CREATE 和 MATCH"></a>CREATE 和 MATCH</h2><p>这一个小节中对<code>CREATE</code>以及<code>MATCH</code>做一个简单的描述和总结，如若在完成了上述章节中的内容还对所使用的语句不是特别理解的话，建议在这一章节中进行巩固。相反，若经过实践已经对Cypher的使用找到了一些感觉，并理解你写下的每一个字符所代表的含义，那么这一章节你大可以跳过。</p><blockquote><p><strong>CREATE</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>CREATE</code> 子句用以创建数据（节点，关系都属于数据）</li><li><code>( )</code>双括弧表示节点</li><li><code>me</code> 变量命，<code>:Person</code> 为这个节点施以指定的标签（也可以没有标签）</li><li><code>&#123; &#125;</code> 花括号用以向节点添加属性，属性值以键值表达</li></ul><blockquote><p><strong>MATCH</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (me:Person) where me.name =&#x27;林羽双珏&#x27; return me</span><br><span class="line">//或</span><br><span class="line">match (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;) return me  // 本文所使用的模式</span><br></pre></td></tr></table></figure><ul><li><p><code>MATCH</code> 子句用以指定节点和关系的模式</p></li><li><p><code>(me:Person)</code> me 为变量名，<code>:Person</code> 用以指定匹配带标签“Person”节点</p></li><li><p><code>where</code> 子句用以约束结果</p></li><li><p><code>me.name = &#39;林羽双珏&#39;</code> 将值与name属性的值进行比较</p></li><li><p><code>return</code> 子句用于请求特定的结果</p></li></ul><blockquote><p><strong>模式匹配</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (me:Person)-[:FRIEND]-(friends)</span><br><span class="line">where me.name = &#x27;林羽双珏&#x27; </span><br><span class="line">    return me , friends</span><br><span class="line">//或</span><br><span class="line">match (me:Person &#123;name:&#x27;林羽双珏&#x27;&#125;)-[:FRIEND]-(friends)</span><br><span class="line">return me , friends</span><br></pre></td></tr></table></figure><ul><li><p><code>MATCH</code> 子句用以描述从已知节点找到节点的模式</p></li><li><p><code>-[:FRIEND]-</code> 匹配“FRIEND”这一关系，如果不带有箭头<code>&gt;</code>或<code>&lt;</code>则表示任何一个方向都可以</p></li><li><p><code>(friends)</code>将匹配到指定 <code>me</code>的<code>FRIEND</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Cypher Query Language (CQL)&lt;/strong&gt; 是 &lt;strong&gt;Neo4j&lt;/strong&gt; 所使用的开放图形查询语言。Cypher 的语法提供了一种方式（类SQL）来匹配图中的节点和关系，也就是&lt;strong&gt;模式&lt;/strong&gt;。如果具备 &lt;strong&gt;SQL&lt;/strong&gt; 的基础，那么学习起 Cypher 就能变得更加容易。这是这篇指引推崇的做法 —— 先掌握SQL基础，再学习 Cypher。除此之外，还需要具备图形数据库和属性图模型的基本概念，以便更好的理解 Cypher 查询。&lt;/p&gt;</summary>
    
    
    
    <category term="Cypher" scheme="http://example.com/categories/Cypher/"/>
    
    
    <category term="CQL" scheme="http://example.com/tags/CQL/"/>
    
  </entry>
  
  <entry>
    <title>K-近邻算法实践：Glass Classification - Kaggle Datasets</title>
    <link href="http://example.com/2018/09/04/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%EF%BC%9AGlass%20Classification%20-%20Kaggle%20Datasets/"/>
    <id>http://example.com/2018/09/04/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%EF%BC%9AGlass%20Classification%20-%20Kaggle%20Datasets/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2022-04-14T03:23:32.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>可从<a href="https://github.com/viusuangio/machine-learning-algorithm#machine-learning-algorithm">GitHub(Glass Classification)</a>下载本文源码以及样本数据集</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要目的是通过 <strong>KNN</strong> 也就是 <strong>k-近邻算法</strong> 来实现一个Glass Classiciation，文中使用的数据来自 <a href="https://www.kaggle.com/uciml/glass/home">Kaggle Datasets</a> ,可以从该页面下载这份数据文件，也可以直接从我 Github 上下载源代码，源代码包括了本文所有内容。 k-近邻算法是 Machine Learning 的一个入门级算法，具备有效性以及易学习。在文章中，我希望通过强调 k-近邻算法 的基本理论，以及如何使用距离测量的方法来进行分类，理论部分的内容十分重要，这关乎到你是否能够理解在面对什么样的数据时可以采用 KNN ，而什么时候又不是那么的适合。</p><span id="more"></span><p>简单来说，k-近邻算法采用测量不同特征值之间的距离，来对数据进行分类。这个距离的计算也是十分简单的，如果你不知道什么是 <a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%BA%A6%E9%87%8F/1274107?fr=aladdin">欧式距离公式</a> (也有人称它为欧几里得度量法)，那么建议先去了解一下，它是比较简单易懂的。另外代码实现部分，将会使用Python，所以前提要求是你需要学会最基本的Python语法。如果你不懂Python——互联网上有非常多关于 Python 的教程，个人建议可以看看 <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰的Python教学</a> ， 如果有人认为这个是广告，请联系一下廖雪峰让他支付一下广告费。：)</p><table><thead><tr><th align="center">k-近邻算法</th><th></th></tr></thead><tbody><tr><td align="center">优点</td><td>具有较高的精度，且对异常值不敏感、无数据输入假定</td></tr><tr><td align="center">缺点</td><td>计算复杂度较高（即计算效率并不是那么理想），空间复杂度高</td></tr><tr><td align="center">适用</td><td>数值型数据以及标称型数据</td></tr></tbody></table><p>上表对 KNN 的优缺点以及适用范围进行了简单的描述，当前若没有直观的印象，可以在接下来的内容中，逐一去理解，我会尽量将所有可能存在的疑问，以及实现的每一个步骤都描述清楚。如果文章中的描述有所纰漏，希望能够及时指出，我的邮箱地址为：<strong><a href="mailto:&#x6c;&#x69;&#x6e;&#121;&#x75;&#64;&#115;&#x7a;&#107;&#x69;&#x6e;&#103;&#x64;&#x6f;&#109;&#46;&#x63;&#111;&#x6d;">&#x6c;&#x69;&#x6e;&#121;&#x75;&#64;&#115;&#x7a;&#107;&#x69;&#x6e;&#103;&#x64;&#x6f;&#109;&#46;&#x63;&#111;&#x6d;</a></strong>，不甚感激。</p><h2 id="k-近邻算法概述"><a href="#k-近邻算法概述" class="headerlink" title="k - 近邻算法概述"></a>k - 近邻算法概述</h2><p> 我们现在先假设存在某数据集合 <strong>Datasets</strong> ，将其视为样本。这个样本数据集合中每一个数据都存在一个标签，换句话说，我们能够知道这个样本数据集中的每一数据，与所属分类的一个对应关系是什么。当我们输入没有进行标记的数据时，将新数据的每个特征与样本数据集中数据对应的特征进行比较，然后通过算法提取出在这个样本数据集中，特征最为相似的数据（近邻数据）的分类标签。在一般情况下，只需要提取样本数据集中 k 个近邻数据，通常不会大于20个，那么在 k 个数据中出现最多的标签，即是新数据的标签。</p><p>举一个简单的例子来理解上面这段话的描述。详见下表样本数据集的表示，即通过一部电影中出现的打斗镜头，以及接吻镜头，为其指定标签为动作片或爱情片。当输入新的数据，打斗镜头有18个，接吻镜头有90个，通过算法我们来计算这个新输入的电影，应该是哪一种类型。</p><table><thead><tr><th align="center">电影名称(数据)</th><th align="center">打斗镜头(数据)</th><th align="center">接吻镜头(数据)</th><th align="center">电影类型(标签)</th></tr></thead><tbody><tr><td align="center">California Man</td><td align="center">3</td><td align="center">104</td><td align="center">爱情片</td></tr><tr><td align="center">He’s Not Really into Dudes</td><td align="center">2</td><td align="center">100</td><td align="center">爱情片</td></tr><tr><td align="center">Beautiful Woman</td><td align="center">1</td><td align="center">81</td><td align="center">爱情片</td></tr><tr><td align="center">Kevin Longblade</td><td align="center">101</td><td align="center">10</td><td align="center">动作片</td></tr><tr><td align="center">Robo Slayer 3000</td><td align="center">99</td><td align="center">5</td><td align="center">动作片</td></tr><tr><td align="center">Amped II</td><td align="center">98</td><td align="center">2</td><td align="center">动作片</td></tr><tr><td align="center"><strong>?</strong></td><td align="center"><strong>18</strong></td><td align="center"><strong>90</strong></td><td align="center">未确认</td></tr></tbody></table><p>通过欧式距离公式我们计算出新电影数据距离样本数据的距离（这里先不纠结于怎么计算出来的，随后我会进行详细解释）</p><table><thead><tr><th align="center">电影名称(数据)</th><th align="center">与新数据的距离</th></tr></thead><tbody><tr><td align="center">California Man</td><td align="center">20.5</td></tr><tr><td align="center">He’s Not Really into Dudes</td><td align="center">18.7</td></tr><tr><td align="center">Beautiful Woman</td><td align="center">19.2</td></tr><tr><td align="center">Kevin Longblade</td><td align="center">115.3</td></tr><tr><td align="center">Robo Slayer 3000</td><td align="center">117.4</td></tr><tr><td align="center">Amped II</td><td align="center">118.9</td></tr></tbody></table><p> 在这个距离表中我们能够很直观的找到与新数据距离最近的几部电影，假设 <strong>k &#x3D; 3</strong>（意思为找出3个距离最近），那么就是 <strong>He’s Not Really into Dudes</strong> 、 <strong>Beautiful Woman</strong> 以及 <strong>California Man</strong> 这三部电影。</p><table><thead><tr><th align="center">电影名称(数据)</th><th align="center">打斗镜头(数据)</th><th align="center">接吻镜头(数据)</th><th align="center">电影类型(标签)</th></tr></thead><tbody><tr><td align="center">He’s Not Really into Dudes</td><td align="center">2</td><td align="center">100</td><td align="center">爱情片</td></tr><tr><td align="center">Beautiful Woman</td><td align="center">1</td><td align="center">81</td><td align="center">爱情片</td></tr><tr><td align="center">California Man</td><td align="center">3</td><td align="center">104</td><td align="center">爱情片</td></tr></tbody></table><p>我们在 k 这个集中找出出现最多的电影类型(标签)，决定新数据的电影类型。显而易见，这里的三部电影都为爱情片，因此我们判定输入的新数据是一部爱情电影。</p><pre><code>KNN的具体实现流程：</code></pre><ol><li>数据收集：可以自己记录数据并设定标签，形成样本数据，也可以从一些开放数据网站找到数据</li><li>数据准备：计算距离时需要的数值，最好是结构化数据格式</li><li>分析数据：可以使用Python的numpy+Matplotlib等，方法不限</li><li>测试算法：计算错误率，调整参数</li><li>使用算法：输入新数据，通过算法输出结果，运算 KNN 判定输入数据的分类，执行后续业务处理</li></ol><p>这个流程中，数据收集步骤在本文开头就已经做好了，即下载我们所需要样本数据集。如果没有下载，现在该准备一下了，接下来我们就进行实际操作。</p><h2 id="从文件中解析数据"><a href="#从文件中解析数据" class="headerlink" title="从文件中解析数据"></a>从文件中解析数据</h2><p>拿到样本数据集的第一件事情并不是直接开始编写代码，而是先分析确认这个样本数据集中的主要特征。首先打开下载来的Datasets : <strong>glass.csv</strong>，每个样本数据一行，共有214行，其中包含的主要特征如下：</p><table><thead><tr><th align="center">特征</th><th align="center">特征含义</th></tr></thead><tbody><tr><td align="center">RI</td><td align="center">折射率</td></tr><tr><td align="center">Na</td><td align="center">钠元素</td></tr><tr><td align="center">Mg</td><td align="center">镁元素</td></tr><tr><td align="center">Al</td><td align="center">铝元素</td></tr><tr><td align="center">Si</td><td align="center">硅元素</td></tr><tr><td align="center">K</td><td align="center">钾元素</td></tr><tr><td align="center">Ca</td><td align="center">钙元素</td></tr><tr><td align="center">Ba</td><td align="center">钡元素</td></tr><tr><td align="center">Fe</td><td align="center">铁元素</td></tr></tbody></table><p>其中的 <strong>Type</strong> 为标签，以 <strong>1-7</strong> 的数字作为标记，按照数据提供方描述，分别对应的玻璃类型如下：</p><table><thead><tr><th align="center">标签值</th><th align="center">玻璃类型</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">建筑窗户浮法玻璃</td></tr><tr><td align="center">2</td><td align="center">建筑窗户无浮法玻璃</td></tr><tr><td align="center">3</td><td align="center">汽车浮法玻璃</td></tr><tr><td align="center">4</td><td align="center">（ 本样本数据集中没有这类型数据 ）</td></tr><tr><td align="center">5</td><td align="center">容器玻璃</td></tr><tr><td align="center">6</td><td align="center">餐具玻璃</td></tr><tr><td align="center">7</td><td align="center">前照灯玻璃</td></tr></tbody></table><p>那么现在我们对样本数据已经具备一定的了解了，要做的是输入新的各项特征值，然后能够通过KNN算法进行分类，将新数据标记出1-7的玻璃类型。接下来我们就着重实现，将这些特征数据输入到CNN算法中，构建一个分类器。</p><h3 id="将样本数据集转换为NumPy的解析方法"><a href="#将样本数据集转换为NumPy的解析方法" class="headerlink" title="将样本数据集转换为NumPy的解析方法"></a>将样本数据集转换为NumPy的解析方法</h3><p>首先我们先将CSV文件中的所有数据（除了第一行，那是表头）复制，然后粘贴到新建的txt文本中并保存为glass.txt，拿txt当作样本数据文件，里面应该只包含如下类似数据</p><pre><code>1.5176613.213.691.2972.610.578.2200    11.5174213.273.621.2473.080.558.0700    11.5159612.793.611.6272.970.648.0700.261…………1.5206514.3602.0273.4208.441.64071.5165114.3801.9473.6108.481.57071.5171114.2302.0873.3608.621.6707</code></pre><p>随即我们创建一个KNN.py的Python模块，并在其中构建一个 <strong>file2matrix</strong> 函数，这个函数用来处理输入格式，传入文件名字符串，返回样本矩阵以及类标签向量。如果你不了解什么是矩阵，请随后去补充学习这方面的知识。这里仅简单说一下返回的样本矩阵 —— 该矩阵的总行数为样本数据的总行数，即已知的 <strong>214</strong> 行 ，而列则是 样本数据中的<strong>9</strong> 个特征，即为9列，所以返回的将会是一个 <strong>214 * 9</strong> 的矩阵 ；</p><p>在写代码之前，导包:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p><strong>file2matrix</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">file2matrix</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="comment"># 读取文本文件数据</span></span><br><span class="line">    file = <span class="built_in">open</span>(filename)</span><br><span class="line">    data_array = file.readlines()</span><br><span class="line">    lines_count = <span class="built_in">len</span>(data_array)</span><br><span class="line">    <span class="comment"># 创建NumPy矩阵以及类标签向量</span></span><br><span class="line">    sample_mat = np.zeros((lines_count, <span class="number">9</span>))  <span class="comment"># 1</span></span><br><span class="line">    class_label_vector = [] <span class="comment"># 2</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 解析文本数据到列表中</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data_array:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        list_from_line = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        sample_mat[index, :] = list_from_line[<span class="number">0</span>:<span class="number">9</span>]</span><br><span class="line">        class_label_vector.append(<span class="built_in">int</span>(list_from_line[-<span class="number">1</span>]))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sample_mat, class_label_vector</span><br></pre></td></tr></table></figure><pre><code>注释：#1 - 利用NumPy构建矩阵，np.zeros(矩阵行数，矩阵列数)#2 - 构建一个array,存放类标签向量</code></pre><p>我们可以验证一下获取到的矩阵和类标签向量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sample_mat,class_label_vector = file2matrix(<span class="string">&quot;glass.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sample_mat)</span><br><span class="line"><span class="built_in">print</span>(class_label_vector[:<span class="number">20</span>])  <span class="comment"># 输出前20个，输出全部也行，去掉 [:20]</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[[ 1.52101 13.64    4.49    ...  8.75     0.       0.     ]</span><br><span class="line">[ 1.51761 13.89     3.6     ...  7.83     0.       0.     ]</span><br><span class="line">[ 1.51618 13.53     3.55    ...  7.78     0.       0.     ]</span><br><span class="line">...</span><br><span class="line">[ 1.52065 14.36     0.      ...  8.44     1.64     0.     ]</span><br><span class="line">[ 1.51651 14.38     0.      ...  8.48     1.57     0.     ]</span><br><span class="line">[ 1.51711 14.23     0.      ...  8.62     1.67     0.     ]]</span><br><span class="line">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span><br></pre></td></tr></table></figure><p>根据输出结果已经却认，现在已经成功的从文本文件中导入了样本数据，并且按照我们想要的格式进行了处理，接下来就需要对些数据的真实含义了，为了能够更直观的浏览，用图形化方式展示一下数据，以便辨识数据模式。</p><h3 id="使用Matplotlib创建散点图"><a href="#使用Matplotlib创建散点图" class="headerlink" title="使用Matplotlib创建散点图"></a>使用Matplotlib创建散点图</h3><p>在KNN中创建新的函数 <strong>data2view</strong> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data2view</span>(<span class="params">sample_mat, class_label_vector</span>):</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    ax.scatter(sample_mat[:, <span class="number">0</span>], sample_mat[:, <span class="number">4</span>], <span class="number">2</span> * np.array(class_label_vector), <span class="number">2</span> * np.array(class_label_vector))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>其中的<code>[:, 0]</code>表示为X轴表示从传入的矩阵中取所有行的第一列，第一列所代表的是 RI (折射率)，<code>[:, 4]</code>表示矩阵所有行的第五列，也就是Si（硅元素）。以此类推你可以自己修改这两个参数所取的列数，查看分类在这两个特征值之间的散点分布的情况进行分析。当然Matplotlib除了构建散点图之外还可以构建出其他的图表，你可以通过自己学习Matplotlib来实现，本文重点仅倾向于实现 k-近邻算法。</p><p>通过对样本数据的分析不难发现，玻璃的主要构成元素是硅元素，所以散点图是想表示不同分类的玻璃在折射率和硅元素含量这样的一张二维表上的分布情况。</p><p><img src="https://s1.ax1x.com/2018/09/04/iSWyAe.png" alt="iSWyAe.png"></p><h3 id="KNN算法的实现"><a href="#KNN算法的实现" class="headerlink" title="KNN算法的实现"></a>KNN算法的实现</h3><p>在上一小节中我们构建了一张散点图来分析硅元素和折射率对玻璃分类的一个影响，实际上我们也不需要太过于关于去分析这张图，因为我接下来要说的是如何计算计算两个向量点 <strong>xA</strong> 和 <strong>xB</strong>之间的距离，将会用到<strong>欧式距离公式</strong>：<br>$$<br>\Large d&#x3D;\sqrt{(xA_0-xB_0)^2+(xA_1-xB_1)^2}<br>$$<br>这个公式十分的简单，例如要计算点（1，2）与（3，4）之间的距离：<br>$$<br>\sqrt{(3-1)^2+(4-2)^2}<br>$$<br>那么如果数据集存在着多个特征值，则点（1，0，0，1，0）与（2，5，2，3，4）之间的距离计算为：<br>$$<br>\sqrt{(2-1)^2+(5-0)^2+(2-0)^2+(3-1)^2+(4-0)^2}<br>$$<br>在此我假设你已经学会了如何使用欧式距离公式，那么接下来我们就该设计一下具体的KNN算法实现，先做一段伪代码，根据伪代码我们还能够理清思路，让真正的代码编写工作变得有条不紊：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对未知类别属性的数据集中的每个点一次执行一下操作：</span><br><span class="line">（1）计算已知类别数据集中的点与当前点之间的距离；</span><br><span class="line">（2）按照距离进行递增排序（即从小到大排序）</span><br><span class="line">（3）选取与当前点距离最近的 k 个点</span><br><span class="line">（4）确定 k 个点中类别的出现频率</span><br><span class="line">（5）返回前 k 个点出现频率最高的类别作为当前点的预测结果</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">    <span class="comment"># 计算距离</span></span><br><span class="line">    dataset_size = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(np.tile(inX, (dataset_size, <span class="number">1</span>)))</span><br><span class="line">    diff_mat = np.tile(inX, (dataset_size, <span class="number">1</span>)) - dataSet</span><br><span class="line">    <span class="built_in">print</span>(diff_mat)</span><br><span class="line">    sq_diff_mat = diff_mat ** <span class="number">2</span></span><br><span class="line">    sq_distances = sq_diff_mat.<span class="built_in">sum</span>(axis = <span class="number">1</span>)</span><br><span class="line">    distances = sq_distances ** <span class="number">0.5</span></span><br><span class="line">    <span class="built_in">print</span>(distances)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择距离最小的k个点</span></span><br><span class="line">    sorted_distances = distances.argsort()</span><br><span class="line">    class_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        label = labels[sorted_distances[i]]</span><br><span class="line">        class_count[label] = class_count.get(label, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 排序</span></span><br><span class="line">    sorted_class_count = <span class="built_in">sorted</span>(class_count.items(), key=operator.itemgetter(<span class="number">1</span>),  reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sorted_class_count[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用样本中数据进行一个简单的测试</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;可能分类：&quot;</span>, classify([<span class="number">1.52101</span>, <span class="number">13.64</span>, <span class="number">4.49</span>, <span class="number">1.1</span>, <span class="number">71.78</span>, <span class="number">0.06</span>, <span class="number">8.75</span>, <span class="number">0</span>, <span class="number">0</span>], sample_mat, class_label_vector, <span class="number">5</span>))  <span class="comment"># 分类:1 ， 返回:1  √</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;可能分类：&quot;</span>, classify([<span class="number">1.53125</span>, <span class="number">10.73</span>, <span class="number">0</span>, <span class="number">2.1</span>, <span class="number">69.81</span>, <span class="number">0.58</span>, <span class="number">13.3</span>, <span class="number">3.15</span>, <span class="number">0.28</span>], sample_mat, class_label_vector, <span class="number">5</span>))  <span class="comment"># 分类:2 ， 返回:2  √</span></span><br></pre></td></tr></table></figure><h3 id="归一化特征值"><a href="#归一化特征值" class="headerlink" title="归一化特征值"></a>归一化特征值</h3><p>从简单的输出测试中我们已经能够看到，似乎是完成了KNN算法。但是这里不得不提出一个问题，让我看来手写一下这个程序中的方程式：<br>$$<br>\sqrt{(1.53125-1.52101)^2+(10.73-13.64)^2+……+(2.1-1.1)^2+(69.81-71.78)^2+……}<br>$$<br>应该不难看出，整个公式中，数字差值问题是会影响到计算结果的，在每一组方程计算中，可能都会出现某一特征值过大于其他特征值。我们或许可以这样认为：要对玻璃进行分类，样本数据中玻璃所有构成元素以及折射率应该都是<strong>等权重</strong>的，不应该出现某一个值过大于其他值，从而照成计算的影响。</p><p>那么在处理这样不同取值范围的特征值时，可以采用数值归一化，将取值范围处理为0到1或者-1到1的区间。<br>$$<br>归一化值 &#x3D; \frac{输入值-数据集中最小值}{数据集中最大值-数据集中最小值}<br>$$</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">norm4knn</span>(<span class="params">dataset</span>):</span><br><span class="line">    min_values = dataset.<span class="built_in">min</span>(<span class="number">0</span>)</span><br><span class="line">    max_values = dataset.<span class="built_in">max</span>(<span class="number">0</span>)</span><br><span class="line">    ranges = max_values - min_values</span><br><span class="line">    norm_dataset = np.zeros(np.shape(dataset))</span><br><span class="line">    m = dataset.shape[<span class="number">0</span>]</span><br><span class="line">    norm_dataset = dataset - np.tile(min_values, (m, <span class="number">1</span>))</span><br><span class="line">    norm_dataset = norm_dataset/np.tile(ranges, (m, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> norm_dataset, ranges, min_values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试norm4knn</span></span><br><span class="line">norm_dataset, ranges, min_values = norm4knn(sample_mat)</span><br><span class="line"><span class="built_in">print</span>(norm_dataset)</span><br><span class="line"><span class="built_in">print</span>(ranges)</span><br><span class="line"><span class="built_in">print</span>(min_values)</span><br></pre></td></tr></table></figure><h3 id="对算法进行验证"><a href="#对算法进行验证" class="headerlink" title="对算法进行验证"></a>对算法进行验证</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testing4knn</span>():</span><br><span class="line">    ho_ratio = <span class="number">0.005</span></span><br><span class="line">    sample_mat,class_label_vector = file2matrix(<span class="string">&quot;glass.txt&quot;</span>)</span><br><span class="line">    norm_dataset, ranges, min_values = norm4knn(sample_mat)</span><br><span class="line">    m = norm_dataset.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;m=&#x27;</span>,m)</span><br><span class="line">    num_test_vecs = <span class="built_in">int</span>(m * ho_ratio)</span><br><span class="line">    <span class="built_in">print</span>(num_test_vecs)</span><br><span class="line">    error_count = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test_vecs):</span><br><span class="line">        classifier_result = classify(norm_dataset[i, :], norm_dataset[num_test_vecs:m, :], class_label_vector[num_test_vecs : m], <span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;分类器分类 : %d, 实际分类 : %d&quot;</span> % (classifier_result, class_label_vector[i]))</span><br><span class="line">        <span class="keyword">if</span> (classifier_result != class_label_vector[i]):</span><br><span class="line">            error_count += <span class="number">1.0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分类器分类错误率 : %f&quot;</span> % (error_count / <span class="built_in">float</span>(num_test_vecs)))</span><br><span class="line"></span><br><span class="line">testing4knn()</span><br></pre></td></tr></table></figure><h3 id="编写分类预测程序"><a href="#编写分类预测程序" class="headerlink" title="编写分类预测程序"></a>编写分类预测程序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">classifyGlass</span>():</span><br><span class="line">    resultList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">    inp_ri = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;折射率:&quot;</span>))</span><br><span class="line">    inp_na = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Na:&quot;</span>))</span><br><span class="line">    inp_mg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Mg:&quot;</span>))</span><br><span class="line">    inp_Al = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Al:&quot;</span>))</span><br><span class="line">    inp_Si = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Si:&quot;</span>))</span><br><span class="line">    inp_K = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;K:&quot;</span>))</span><br><span class="line">    inp_Ca = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Ca:&quot;</span>))</span><br><span class="line">    inp_Ba = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Ba:&quot;</span>))</span><br><span class="line">    inp_Fe = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Fe:&quot;</span>))</span><br><span class="line">    datingDataMat, datingLabels = file2matrix(<span class="string">&#x27;glass.txt&#x27;</span>)</span><br><span class="line">    normMat, ranges, minVals = norm4knn(datingDataMat)</span><br><span class="line">    inArr = np.array([inp_ri, inp_na, inp_mg, inp_Al, inp_Si, inp_K, inp_Ca, inp_Ba, inp_Fe])</span><br><span class="line">    classifierResult = classify((inArr - minVals)/ranges, normMat, datingLabels, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该玻璃分类可能为:&quot;</span>, resultList[classifierResult - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">classifyGlass()</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">running &amp; result</span><br><span class="line"></span><br><span class="line">折射率<span class="punctuation">:</span><span class="number">1.52101</span></span><br><span class="line">Na<span class="punctuation">:</span><span class="number">13.64</span></span><br><span class="line">Mg<span class="punctuation">:</span><span class="number">4.49</span></span><br><span class="line">Al<span class="punctuation">:</span><span class="number">1.1</span></span><br><span class="line">Si<span class="punctuation">:</span><span class="number">71.78</span></span><br><span class="line">K<span class="punctuation">:</span><span class="number">0.06</span></span><br><span class="line">Ca<span class="punctuation">:</span><span class="number">8.75</span></span><br><span class="line">Ba<span class="punctuation">:</span><span class="number">0</span></span><br><span class="line">Fe<span class="punctuation">:</span><span class="number">0</span></span><br><span class="line">该玻璃分类可能为<span class="punctuation">:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;可从&lt;a href=&quot;https://github.com/viusuangio/machine-learning-algorithm#machine-learning-algorithm&quot;&gt;GitHub(Glass Classification)&lt;/a&gt;下载本文源码以及样本数据集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要目的是通过 &lt;strong&gt;KNN&lt;/strong&gt; 也就是 &lt;strong&gt;k-近邻算法&lt;/strong&gt; 来实现一个Glass Classiciation，文中使用的数据来自 &lt;a href=&quot;https://www.kaggle.com/uciml/glass/home&quot;&gt;Kaggle Datasets&lt;/a&gt; ,可以从该页面下载这份数据文件，也可以直接从我 Github 上下载源代码，源代码包括了本文所有内容。 k-近邻算法是 Machine Learning 的一个入门级算法，具备有效性以及易学习。在文章中，我希望通过强调 k-近邻算法 的基本理论，以及如何使用距离测量的方法来进行分类，理论部分的内容十分重要，这关乎到你是否能够理解在面对什么样的数据时可以采用 KNN ，而什么时候又不是那么的适合。&lt;/p&gt;</summary>
    
    
    
    <category term="Machine Learning" scheme="http://example.com/categories/Machine-Learning/"/>
    
    
    <category term="Algorithem" scheme="http://example.com/tags/Algorithem/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱 Knowledge Graph</title>
    <link href="http://example.com/2018/09/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%20Knowledge%20Graph/"/>
    <id>http://example.com/2018/09/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%20Knowledge%20Graph/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2018-09-04T11:32:06.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part-I：知识图谱概念"><a href="#Part-I：知识图谱概念" class="headerlink" title="Part I：知识图谱概念"></a>Part I：知识图谱概念</h2><p>知识图谱这个概念最早是由 Google 于 2012年5月 率先提出的，目的是<strong>将用户搜索的结果进行知识系统化，让每一个关键字都拥有一个完整的知识体系，从而真正意义上实现基于内容检索，提高搜索质量</strong>。Google 提出的知识图谱在某种程度上，可能将被指向下一代智能搜索引擎的核心。借用幸格博士的一句话：The world is not made of strings , but is made of things . 即构成这个世界的并非是字符串，而是实体。</p><span id="more"></span><p><img src="https://s1.ax1x.com/2018/09/04/iSR8JA.jpg" alt="iSR8JA.jpg"></p><p>上面这张图谱表明了《人民的名义》中各个角色之间的关系。可以看出如果两个人之间存在关系，则会被一条线连接在一起，这样被连接起来的两个对象，可以称之为 <strong>实体（Entity）</strong>或 <strong>节点（Point）</strong>, 而这条线可以被称之为 <strong>关系（Relationship）</strong> 或 <strong>边（Edge）</strong>。</p><p>这张图谱的实体数量并不是非常多，所存在实体间关系也能很清楚的看清，但是如果涉及到实体成百上千的时候呢？再来看看知名电影《Start Wars》中228种实体构成的知识图谱。</p><p><img src="https://s1.ax1x.com/2018/09/04/iSRGRI.jpg" alt="iSRGRI.jpg"></p><p>错综复杂的关系这个时候已经不是人脑可以在短时间内理解清楚的了。但根据这两张图，应该不难理解，知识图谱本质上就是如这两张图一样，展示出来的是一个<strong>语义网络</strong>，这是一种基于图的数据结构，是由 实体（节点）和 关系（边）组成的。</p><p>这里对提及的语义网络做一个简单的说明：<span style="color:red"><strong>语义网络是由数据构成的，向用户提供的是一个查询环境，其核心要以是以图形的方式向用户返回经过加工和推理的知识。而知识图谱技术则是实现智能化语义检索的基础。</strong></span></p><p>总而言之，知识图里的每一个节点表示显示世界中存在的实体，每一条边为实体与实体之间的关系。这样就形成了知识图谱的基本组成单位，即 <strong>实体 —— 关系 —— 实体</strong> 这样的三元组，同时还有实体的相关属性和值对。</p><h2 id="Part-II：知识图谱架构"><a href="#Part-II：知识图谱架构" class="headerlink" title="Part II：知识图谱架构"></a>Part II：知识图谱架构</h2><p>  知识图谱的架构包括了知识图谱自身的<strong>逻辑架构</strong>以及构建知识图谱所采用的<strong>技术架构</strong>。</p><h3 id="Part-II-A：逻辑架构"><a href="#Part-II-A：逻辑架构" class="headerlink" title="Part II - A：逻辑架构"></a>Part II - A：逻辑架构</h3><p>  在逻辑的层面可以将知识图谱划分为两个层次： <strong>数据层以及模式层</strong>。</p><ul><li><p>数据层：用以存储真实的数据。</p></li><li><p>模式层：是数据层之上的一个层，是知识图谱的核心部分，存储的是已经通过提炼后的知识。通常是使用<strong>本体库</strong>来管理这一层。 本体库类似OO思想中类的概念，存储者知识图谱的类。</p><p>这两个层之间的区别可以通过下面这个例子来进行理解：</p></li></ul><blockquote><p>模式层：实体—关系—实体，实体—属性—值</p><p>数据层：罗贯中—作品—《三国演绎》，罗贯中—朝代—明朝</p></blockquote><h3 id="Part-II-B：技术架构"><a href="#Part-II-B：技术架构" class="headerlink" title="Part II - B：技术架构"></a>Part II - B：技术架构</h3><p>知识图谱的整体架构可以用下图表示，其中虚线框中的部分为知识图谱的构建过程，同时也是它的更新过程 。</p><p><img src="https://s1.ax1x.com/2018/09/04/iSRJzt.png" alt="iSRJzt.png"></p><p>按照技术架构，我们可以理清知识图谱的构建思路。首先是海量数据，可能是结构化数据，或非结构化数据，或半结构化数据，然后我们基于数据来构建知识图谱。<strong>这一个步骤主要是通过一系列自动化或半自动化的技术手段，来从原始数据中提取出知识要素，即实体关系，并将其存入知识库的模式层和数据层。</strong></p><p>构建知识图谱是一个迭代更新的过程 ，根据知识获取的逻辑，每一轮迭代都包含主要三个阶段：</p><ol><li><strong>信息抽取（Information Acquisition）</strong>: 从数据源中提取出实体、属性以及实体间的相互关系，在此基础上形成本体化的知识表达；</li><li><strong>知识融合（Knowledge Fusion）</strong>： 在获取到了新的知识之后 ，需要进行对新知识的整合，以消除矛盾和歧义。 比如某些实体可能有多种表达，某个特定的成为也许对应多个不同的实体等；</li><li><strong>知识加工（Knowledge Processing）</strong>：对于经过融合的新知识，需要经过质量评估之后（部分需要人工参与甄别），才能够将合格的部分加入到知识库中 ，以确保知识库的质量保持在较高的水准上。</li></ol><h3 id="Part-II-C：知识图谱的展示"><a href="#Part-II-C：知识图谱的展示" class="headerlink" title="Part II - C：知识图谱的展示"></a>Part II - C：知识图谱的展示</h3><p>上述已经提到说数据的来源无非为三种： <strong>结构化数据、半结构化数据、非结构化数据</strong>，前两者多以Wikipedia 以及百度百科为代表的大规模知识库，这些知识库中已经包含了大量半结构化、结构化知识，可以高效的转化到知识图谱中。然而非结构化数据多是文本数据。</p><p>知识图谱中的数据存储多以<strong>RDF三元组</strong>，可以借助 <strong>Neo4j</strong> 进行可视化展示。</p><p><img src="https://s1.ax1x.com/2018/09/04/iSRlIH.png" alt="iSRlIH.png"></p><p><img src="https://s1.ax1x.com/2018/09/04/iSR3id.jpg" alt="iSR3id.jpg"></p><h2 id="Part-III-：知识图谱构建"><a href="#Part-III-：知识图谱构建" class="headerlink" title="Part III ：知识图谱构建"></a>Part III ：知识图谱构建</h2><p><img src="https://s1.ax1x.com/2018/09/04/iSRwdg.png" alt="iSRwdg.png"></p><h3 id="Part-III-A-：信息抽取（Information-Acquisition）"><a href="#Part-III-A-：信息抽取（Information-Acquisition）" class="headerlink" title="Part III - A ：信息抽取（Information Acquisition）"></a>Part III - A ：信息抽取（Information Acquisition）</h3><p>还是按照知识图谱的技术架构图，<strong>信息抽取（Information Acquisition）</strong> 是知识图谱构架的第一步，其中最为关键的一个问题是： <strong>如何从异构数据源中自动抽取信息得到候选指示单元</strong>。我们需要从半结构化以及非结构化数据中进行<strong>实体抽取（Entity Extraction）、关系抽取（Relation Extraction）以及属性抽取（Attribute Extraction）</strong>。</p><h4 id="Part-III-A-1：实体抽取（Entity-Extraction）"><a href="#Part-III-A-1：实体抽取（Entity-Extraction）" class="headerlink" title="Part III - A - 1：实体抽取（Entity Extraction）"></a>Part III - A - 1：实体抽取（Entity Extraction）</h4><p>实体抽取也被成为<strong>命名实体识别（Named entity recognition , NER）</strong>，是指从文本数据集中自动识别出命名的实体。</p><blockquote><p><strong>【 NER 的研究历史 】</strong> </p><ul><li><strong>面向单一领域（single domain）</strong>：关注如何识别文本中人名、地名等专有名词以及具有具体意义的时间等实体信息：</li></ul><ol><li>启发式算法 + 人工规则， 实现自动抽取实体的原型系统</li><li>统计机器学习方法辅助解决命名实体抽取问题</li><li>监督学习+先验知识</li></ol><ul><li><strong>关注开放域（open domain）</strong>：不在限定于特定的知识领域 ，而是面向开放的互联网，研究和解决全网信息抽取问题：</li></ul><ol><li>人工建立科学完整的命名实体分类体系</li><li>基于归纳总结的实体类，基于条件随机场（CRF）模型进行实体边界识别，最后采用自适应感知机实现对实体的自动分类</li><li>采用统计机器学习方法，从目标数据集中抽取出与之具有相似上下文特征的实体，从而实现实体的分类和聚类</li><li>迭代扩展实体语料库</li><li>通过搜索引擎的服务器日志，聚类获取新出现的命名实体  —— 已经应用于自动补全技术</li></ol></blockquote><p>实体抽取的质量（准确率和召回率）对后续的知识获取效率和质量影响极大，因此是信息抽取中最为基础和关键的部分。</p><h4 id="Part-III-A-2：关系抽取（Relations-Extraction）"><a href="#Part-III-A-2：关系抽取（Relations-Extraction）" class="headerlink" title="Part III - A - 2：关系抽取（Relations Extraction）"></a>Part III - A - 2：关系抽取（Relations Extraction）</h4><p>文本语料经过了实体抽取，得到的是一系列的离散数据，也就是离散实体。为了得到语义信息，还需要从相关的预料中提取出实体之间的关联关系，通过关联关系将<strong>实体</strong>通过<strong>关系</strong>联系起来，才能够形成网状的知识结构，研究关系抽取技术的目的，<strong>是解决如何从文本语料中抽取实体间的关系这一基本问题</strong></p><blockquote><p><strong>【 关系抽取研究历史 】</strong></p><ol><li>人工构造语法和语义规则（模式匹配）</li><li>统计机器学习方法</li><li>基于特征向量或核函数的有监督学习方法</li><li>研究重点转向半监督和无监督</li><li>开始研究面向开放域的信息抽取方法</li><li>将面向开放域的信息抽取方法和面向封闭领域的传统方法结合</li></ol></blockquote><p>Banko等人提出了面向开放域的<strong>信息抽取方法框架（open information extraction，OIE）</strong>，并发布了基于自监督（self-supervised）学习方式的<strong>开放信息抽取原型系统（TextRunner）</strong>，该系统采用少量人工标记数据作为训练集，据此得到一个实体关系分类模型，再依据该模型对开放数据进行分类，依据分类结果<strong>训练朴素贝叶斯模型</strong>来识别<strong>实体-关系-实体</strong>三元组，经过大规模真实数据测试，取得了显著优于同时期其他方法的结果。</p><p>TextRunner系统中错误的部分主要是一些无意义或者不和逻辑的实体关系三元组，据此引入语法限制条件和字典约束，采用先识别关系指示词，然后再对实体进行识别的策略，有效提高了关系识别准确率。</p><h4 id="Part-III-A-3：属性抽取（Attribute-Extraction）"><a href="#Part-III-A-3：属性抽取（Attribute-Extraction）" class="headerlink" title="Part III - A -3：属性抽取（Attribute Extraction）"></a>Part III - A -3：属性抽取（Attribute Extraction）</h4><p>属性抽取的目标是从不同信息源中采集特定实体的属性信息。例如针对某个公众人物，可以从网络公开信息中得到其昵称、生日、国籍、教育背景等信息。属性抽取技术能够从多种数据来源中汇集这些信息，实现对实体属性的完整勾画。</p><blockquote><p>【 属性抽取研究历史】</p><ol><li>将实体的属性视作实体与属性值之间的一种名词性关系，将属性抽取任务转化为关系抽取任务</li><li>基于规则和启发式算法，抽取结构化数据</li><li>基于百科类网站的半结构化数据，通过自动抽取生成训练语料，用于训练实体属性标注模型，然后将其应用于对非结构化数据的实体属性抽取</li><li>采用数据挖掘的方法直接从文本中挖掘实体属性和属性值之间的关系模式，据此实现对属性名和属性值在文本中的定位</li></ol></blockquote><h3 id="Part-III-B：知识融合（Knowledge-Fusion）"><a href="#Part-III-B：知识融合（Knowledge-Fusion）" class="headerlink" title="Part III - B：知识融合（Knowledge Fusion）"></a>Part III - B：知识融合（Knowledge Fusion）</h3><p><img src="https://s1.ax1x.com/2018/09/04/iSRtQP.png" alt="iSRtQP.png"></p><p>通过信息抽取后，我们从原始的非结构化和板结构化数据中获取到了实体、关系以及实体的属性<strong>信息</strong>。接下来就是Kownledge Fusion 也就是<strong>知识融合</strong></p><p>如果把知识融合的过程比喻成拼图，那么信息就是一张张拼图碎片，其本质上就是杂乱无章的，甚至还有错误的碎片，会干扰完成拼图。</p><p>若总结起来：</p><ul><li><strong>信息之间的关系是扁平化的，缺乏层次以及逻辑性</strong></li><li><strong>知识中还存在大量冗杂和错误的信息</strong></li></ul><p>如何解决上述的两个问题就是知识融合中需要做的。这包含着两个部分—— <strong>实体链接</strong> 以及 <strong>知识合并</strong>。</p><h4 id="Part-III-B-1：实体链接"><a href="#Part-III-B-1：实体链接" class="headerlink" title="Part III - B - 1：实体链接"></a>Part III - B - 1：实体链接</h4><p><strong>实体链接（entity linking）</strong>是指对于从文本中抽取得到的实体对象 ，将其链接到知识库中对应的正确实体对象的操作。其基本思想是更具给定的<strong>实体指称项</strong>，从知识库中选出一组候选实体对象 ，然后通过相似度计算将指称项链接到正确的实体对象。</p><p>实体链接的一般流程：</p><ul><li>从文本中通过实体抽取得到实体指称项</li><li>进行<strong>实体消歧</strong>和<strong>共指消解</strong>，判断知识库中的同名实体与之是否代表不同的含义，以及知识库中是否存在其他命名实体与之表示相同的含义</li><li>在确认知识库中对应正确实体对象之后，将该实体指称链接到知识库中对应实体</li></ul><blockquote><p><strong>实体消歧</strong>：专门用于解决同名实体产生歧义问题的技术。通过实体消歧能够根据当前语境，结合上下文准确建立实体链接，而实现实体消歧义主要采用聚类算法。（类似词性消歧和词义消歧）</p></blockquote><blockquote><p><strong>共指消解</strong>：主要用于解决多个指称对应同一实体对象的问题。多个指称可能指向的是同一个实体对象，而利用共指消解技术，可以将这些指称项关联到正确的实体对象，由于该问题在信息检索和自然语言处理等领域具有特殊重要性，吸引了大量的研究。共指消解还有一些其他的名字，例如对象对齐、实体匹配、实体同义等 </p></blockquote><h4 id="Part-III-B-2：知识合并"><a href="#Part-III-B-2：知识合并" class="headerlink" title="Part III - B -  2：知识合并"></a>Part III - B -  2：知识合并</h4><p>在开始这个过程之前，我们假设已经完成了实体链接 ，也就是将实体链接到知识库中对应的正确实体对象，但是需要强调的是，<strong>实体链接时所链接的是从半结构化数据以及非结构化数据中通过信息抽取得到的数据</strong>。那么除了这两类之外，还有更方便的数据来源，即<strong>结构化数据</strong>，如外部知识库或关系数据库。</p><p>对于这部分结构化数据的处理即为知识合并，一般来说为两种：<strong>外部知识库合并</strong> 以及 <strong>关系数据库合并</strong>。</p><p>在进行<strong>外部知识库合并</strong>时，主要处理两个层面的问题：</p><ul><li>数据层的融合，包括实体的指称、属性、关系以及所属类别等，主要的问题是如何避免实例以及关系的冲突问题，消除不必要的冗余</li><li>模式层的融合，将新得到的本体融入已有的本体库中</li></ul><p>一般情况下可以按照下列四个步骤：</p><ol><li>获取知识</li><li>概念匹配</li><li>实体匹配</li><li>知识评估</li></ol><p><strong>关系数据库合并</strong>：在构建知识图谱的过程中，一个重要的高质量知识来源是企业或者机构自己的关系数据库。为了将这些结构化的历史数据融入到知识图谱中，可以采用<strong>资源描述框架（RDF）</strong>作为数据模型，这一个数据转换的过程被成为<code>RDB2RDF</code> ，意为将关系数据库的数据换成RDF的三元组数据。</p><h3 id="Part-III-C：知识加工"><a href="#Part-III-C：知识加工" class="headerlink" title="Part III - C：知识加工"></a>Part III - C：知识加工</h3><p><img src="https://s1.ax1x.com/2018/09/04/iSRNsf.png" alt="iSRNsf.png"></p><p>重复看KG的技术架构图，在前面两个步骤中我们已经通过了信息抽取，从原始语料中提取了实体、关系与属性等知识要数，并且经过知识融合，消除了实体指称项与实体对象之间的歧义，得到了一系列基本的事实表达。但是事实本身并不意味着等于知识，想要获得结构化的最终体，网络化的知识体系，还需要经过知识加工的过程。</p><p>知识加工主要包括：<strong>本体构建、知识推理，以及质量评估</strong></p><h4 id="Part-III-C-1：本体构建"><a href="#Part-III-C-1：本体构建" class="headerlink" title="Part III - C - 1：本体构建"></a>Part III - C - 1：本体构建</h4><p><strong>本体（Ontology）</strong>是对概念进行建模的规范，是描述客观世界的抽象模型，以一种形象化的方式对概念以及之间的关系给出明确的定义。本体最大的特点是共享，本体中反映的知识是一种明确定义的知识。在知识图谱中，本体位于 <strong>模式层</strong>，用来描述概念层次体系，是知识库中知识的概念模板。</p><p>本体可以采用人工编辑的方法，通过本体编辑软件来手动构建，但是付出的工作量将会是巨大的。一般来说可以以数据驱动的自动化方式来构建本体。一些面向特定领域自动化本体构建过程包含三个阶段：</p><ol><li><strong>实体并列关系相似度：</strong><ul><li>考察任意两个给定的实体在多大的程度上术语同一概念的指标测度，相似度越高，则越加表明这两个实体可能属于同一语义类别。例如<code>中国</code> \ <code>美国</code>，这是国家的实体名称，具有较高的并列关系相似度，但是 <code>中国</code> \ <code>计算机</code> 这两个实体名称之间的并列关系相似度就是极低的。</li><li><strong>主流计算方法：</strong>模式匹配法和分布相似度。</li></ul></li><li><strong>实体上下位关系抽取：</strong><ul><li>用于确定概念之间的隶属问题，也就是 <strong>IsA</strong> 关系，这种关系也被称之为上下位关系。例如<code>硬件</code> \ <code>磁盘</code> 就构成了上下位关系，<code>磁盘</code>为下位词，而<code>硬件</code>为上位词。</li><li><strong>主要研究方法：</strong> ①基于语法模式（如Hearst模式）抽取IsA实体对；②利用概率模型来判定IsA关系和区分上下位词，通常会借助一些百科类网站提供的概念分类知识来帮助训练模型，用以提高算法的精度；③用跨语言知识链接的方法来构建本体库；</li></ul></li><li><strong>本体的生成</strong><ul><li>本体生成主要是对各个层次得到的概念进行聚类，并且对其进行语义类的标定，<strong>为该类中的实体制定一个或多个公共上位词。</strong></li><li>主要研究方法：实体聚类方法。</li></ul></li></ol><h4 id="Part-III-C-2：知识推理"><a href="#Part-III-C-2：知识推理" class="headerlink" title="Part III - C - 2：知识推理"></a>Part III - C - 2：知识推理</h4><p><strong>知识推理</strong>是从知识库中已有的实体关系数据出发，进行计算机推理，建立实体间的新关联，从而不断的扩展整个知识网络。知识推理也是知识图谱构建的重要手段和环节之一，通过知识推理，能够从现有知识中发现新的知识。例如说我们得知了这样的两个三元组，<code>（A君,父亲,B君）</code>，<code>（B君,弟弟,C君）</code>从而我们能够得知<code>（A君,父亲,C君）</code>。</p><p>除此外知识推理的对象也可以是实体的属性值，本体的概念层次关系等。拿属性值推理来说：当你知道一个人的出生年月日，那么也就能够得知他的年龄，所属时代等。</p><p>知识的推理方法可以分为2大类：<strong>基于逻辑的推理</strong>和<strong>基于图的推理</strong>。</p><ul><li>基于逻辑的推理<ul><li>一阶谓词逻辑：命题被分解为个体（individuals）和谓词（predication）两个部分。个体指的是可以独立存在的客观个体，也可以是一个具体的事物或者抽象的概念。而谓词是刻画个体性质以事物关系的词。比如<code>（A君,朋友,B君）</code>，<code>朋友</code>就是表达个体A君和个体B君关系的谓词。</li><li>描述逻辑：对于比较复杂的实体关系，可以采用描述逻辑进行知识推理。这是一种基于对象的知识表示的形式化工具，是一阶谓词逻辑的子集，是本体语言推理的重要设计基础。</li><li>基于规则的推理：可以利用专门的规则语言，比如<strong>SWRL（Semantic Web Rule Language）</strong></li></ul></li><li>基于图的推理<ul><li>主要基于神经网络模型或者Path Ranking 算法。Path Ranking 算法的基本思想是将知识图谱视为图，从源节点开始，在图上执行随机的游走，如果能够通过一个路径达到目标节点，则可以推出源节点和目标节点存在关系。</li></ul></li></ul><h4 id="Part-III-C-3：质量评估"><a href="#Part-III-C-3：质量评估" class="headerlink" title="Part III - C - 3：质量评估"></a>Part III - C - 3：质量评估</h4><p>质量评估也是知识库构建技术的重要组成部分，这一部分存在的意义在于：可以对知识的可信度进行量化，通过舍弃置信度较低的知识来<strong>保障知识库的质量。</strong></p><h2 id="Part-IV-：知识图谱的更新"><a href="#Part-IV-：知识图谱的更新" class="headerlink" title="Part IV ：知识图谱的更新"></a>Part IV ：知识图谱的更新</h2><p>从逻辑上看，知识库的更新包括<strong>概念层的更新和数据层的更新</strong>。</p><ul><li><strong>概念层的更新</strong>是指新增数据后获得了新的概念，需要自动将新的概念添加到知识库的概念层中。</li><li><strong>数据层的更新</strong>主要是新增或更新实体、关系、属性值，对数据层进行更新需要考虑数据源的可靠性、数据的一致性（是否存在矛盾或冗杂等问题）等可靠数据源，并选择在各数据源中出现频率高的事实和属性加入知识库。</li></ul><p>知识图谱的内容更新有两种方式：</p><ul><li><strong>全面更新：</strong>指以更新后的全部数据为输入，从零开始构建知识图谱。这种方法比较简单，但资源消耗大，而且需要耗费大量人力资源进行系统维护；</li><li><strong>增量更新：</strong>以当前新增数据为输入，向现有知识图谱中添加新增知识。这种方式资源消耗小，但目前仍需要大量人工干预（定义规则等），因此实施起来十分困难。</li></ul><h2 id="Other-I：知识图谱的应用"><a href="#Other-I：知识图谱的应用" class="headerlink" title="Other I：知识图谱的应用"></a>Other I：知识图谱的应用</h2><p>通过知识图谱，不仅可以将互联网的信息表达成更接近人类认知世界的形式，而且提供了一种更好的组织、管理和利用海量信息的方式。目前的知识图谱技术主要用于<strong>智能语义搜索</strong>、<strong>移动个人助理（例如：苹果的Siri，小米的小爱）</strong>以及<strong>深度问答系统（Watson）</strong>，支撑这些应用的核心技术正是知识图谱技术。</p><p>在智能语义搜索中，当用户发起查询时，搜索引擎会借助知识图谱的帮助对用户查询的关键词进行解析和推理，进而将其映射到知识图谱中的一个或一组概念之上，然后根据知识图谱的概念层次结构，向用户返回图形化的知识结构，这就是我们在谷歌和百度的搜索结果中看到的知识卡片。目前知识图谱最成熟的一个场景就是智能语义搜索。</p><p><img src="https://s1.ax1x.com/2018/09/04/iSRUL8.png" alt="iSRUL8.png"></p><p><img src="https://s1.ax1x.com/2018/09/04/iSRdeS.png" alt="iSRdeS.png"></p><p>在深度问答应用中，系统同样会首先在知识图谱的帮助下对用户使用自然语言提出的问题进行语义分析和语法分析，进而将其转化成结构化形式的查询语句，然后在知识图谱中查询答案。比如，如果用户提问：<strong>如何判断是否感染了埃博拉病毒？</strong>则该查询有可能被等价变换为<strong>埃博拉病毒的症状有哪些？</strong>然后再进行推理变换，最终形成等价的三元组查询语句，如<code>（埃博拉，症状，？）</code>和<code>（埃博拉，征兆，？）</code>等。如果由于知识库不完善而无法通过推理解答用户的问题，深度问答系统还可以利用搜索引擎向用户反馈搜索结果，同时根据搜索结果更新知识库，从而为回答后续的提问提前做出准备。</p><p>除此之外，知识图谱的应用还有许多，例如：</p><ul><li><strong>客户管理（适用于多种企业领域）</strong>： 通过构建客户人物关系知识图谱，更好的进行客户信息、关系等管理，挖掘出更多的联系人。</li><li><strong>精准销售分析（适用于多种企业领域）</strong>：一个聪明的企业可以比它的竞争对手以更为有效的方式去挖掘其潜在的客户。在互联网时代，销售手段多种多样，但不管有多少种方式，都离不开一个核心——<strong>分析用户和理解用户</strong>。知识图谱可以结合多种数据源去分析实体之间的关系，从而对用户的行为有更好的理解。比如一个公司的市场经理用知识图谱来分析用户之间的关系，去发现一个组织的共同喜好，从而可以有针对性的对某一类人群制定营销策略。只有我们能更好的、更深入的理解用户的需求，才能更好地去做销售。</li><li><strong>不一致性验证（银行、证券公司）</strong>：可以用来判断一个借款人的欺诈风险，这个跟交叉验证类似。比如借款人张三和借款人李四填写的是同一个公司电话，但张三填写的公司和李四填写的公司完全不一样，这就成了一个风险点，需要审核人员格外的注意。再比如，借款人说跟张三是朋友关系，跟李四是父子关系。当我们试图把借款人的信息添加到知识图谱里的时候，“一致性验证”引擎会触发。引擎首先会去读取张三和李四的关系，从而去验证这个“三角关系”是否正确。很显然，朋友的朋友不是父子关系，所以存在着明显的不一致性。不一致性验证涉及到知识的推理。通俗地讲，知识的推理可以理解成“链接预测”，也就是从已有的关系图谱里推导出新的关系或链接。 比如在上面的例子，假设张三和李四是朋友关系，而且张三和借款人也是朋友关系，那我们可以推理出借款人和李四也是朋友关系。</li></ul><h2 id="Other-II：国内外开放的知识图谱"><a href="#Other-II：国内外开放的知识图谱" class="headerlink" title="Other II：国内外开放的知识图谱"></a>Other II：国内外开放的知识图谱</h2><p>随着知识图谱的概念不断兴起，国内外许多搜索引擎公司和科研机构发布和维护了各类大规模知识库 ，其中有Google 收购的 Freebase 、德国莱比锡大学等机构发起的项目 DBpedia 、德国马普研究所开发的链接数据库 YAGO 、普林斯顿大学开发的语义词典 wordnet 等，国内的如中文知识图谱社区 OpenKG.CN 等</p><p><img src="https://s1.ax1x.com/2018/09/04/iSR0oQ.png" alt="iSR0oQ.png"></p><h2 id="参考资料-x2F-文献"><a href="#参考资料-x2F-文献" class="headerlink" title="参考资料&#x2F;文献"></a>参考资料&#x2F;文献</h2><blockquote><p>【1】<a href="https://arxiv.org/pdf/1711.03438.pdf">Open-World Knowledge Graph Completion</a> - <strong>Baoxu Shi&amp; Tim Weninger</strong> - University of Notre Dame - <a href="https://github.com/bxshi/ConMask">Github Code Link</a></p><p>【2】<a href="https://en.wikipedia.org/wiki/Knowledge_Graph">Knowledge Graph</a> -  Wikipedia</p><p><a href="https://stackoverflow.com/questions/29461062/how-to-build-a-knowledge-graph">【3】How to build a Knowledge Graph</a> - Stack Overflow : <strong>Kikohs</strong></p><p>【4】De Abreu, D., Flores, A., Palma, G., Pestana, V., Pinero, J., Queipo, J., … &amp; Vidal, M. E. (2013). Choosing Between Graph Databases and RDF Engines for Consuming and Mining Linked Data. In COLD.</p><p>【5】Bordes, A., Usunier, N., Garcia-Duran, A., Weston, J., &amp; Yakhnenko, O. (2013). Translating embeddings for modeling multi-relational data. In Advances in Neural Information Processing Systems (pp. 2787-2795).</p><p>【6】Socher, R., Chen, D., Manning, C. D., &amp; Ng, A. (2013). Reasoning with neural tensor networks for knowledge base completion. In Advances in Neural Information Processing Systems (pp. 926-934).</p><p>【7】<a href="https://zhuanlan.zhihu.com/p/43564351">金融知识图谱搭建全攻略</a> - 知乎 - <a href="https://zhuanlan.zhihu.com/lqfarmer">深度学习与NLP</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Part-I：知识图谱概念&quot;&gt;&lt;a href=&quot;#Part-I：知识图谱概念&quot; class=&quot;headerlink&quot; title=&quot;Part I：知识图谱概念&quot;&gt;&lt;/a&gt;Part I：知识图谱概念&lt;/h2&gt;&lt;p&gt;知识图谱这个概念最早是由 Google 于 2012年5月 率先提出的，目的是&lt;strong&gt;将用户搜索的结果进行知识系统化，让每一个关键字都拥有一个完整的知识体系，从而真正意义上实现基于内容检索，提高搜索质量&lt;/strong&gt;。Google 提出的知识图谱在某种程度上，可能将被指向下一代智能搜索引擎的核心。借用幸格博士的一句话：The world is not made of strings , but is made of things . 即构成这个世界的并非是字符串，而是实体。&lt;/p&gt;</summary>
    
    
    
    <category term="Knowledge Graph" scheme="http://example.com/categories/Knowledge-Graph/"/>
    
    
    <category term="KG" scheme="http://example.com/tags/KG/"/>
    
  </entry>
  
</feed>
